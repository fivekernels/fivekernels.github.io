[{"content":"UART 框图 查看芯片对应的 Reference Manual 的 USART/UART 章节可以找到其框图。以 F4 系列的参考手册为例，其框图如下1：\n可以看出，对于发送的数据，依次经过 TDR 寄存器 -\u0026gt; 发送移位寄存器 -\u0026gt; TX 端口；对于接收的数据，从 RX 端口依次经过 接收移位寄存器 -\u0026gt; RDR寄存器。\nUART 寄存器 RXNE(Read data register not empty)：当接收移位寄存器中的数据被传送到 RDR 寄存器时，该位被置1；若打开串口接收中断(RXNEIE)=1时，会产生中断。读取 RDR 寄存器该位自动清零。 TXE(Transmit data register empty)：当TDR 寄存器中的数据被传送到发送移位寄存器时（此时可以向 TDR 寄存器写入新数据发送），该位被置1；若打开串口发送中断(TXEIE=1)时，会产生中断。当向 TDR 寄存器中写入新数据时该位自动清零。 TC(Transmission complete)：当移位寄存器的数据发送完成且 TDR 寄存器为空（没有下一个要发送的数据了）时，该位被置1；若打开发送完成中断(TCIE=1)时，会产生中断。当向 TDR 寄存器中写入新数据时该位自动清零，也可以手动清零。 IDLE(Idle line detected)：空闲位针对接收过程；当串口接收到一个字节后的一个周期内都没有检测到起始位时（即检测到 Idle frame ）， IDLE 被置12 3。当 IDLE 被置1后，只有再次接收到数据后（ RXNE 置1）才会检测下一次空闲。 低功耗串口的时钟和波特率 对于LPUART，其波特率和其时钟源有需要满足一定关系4：\n即LPUART的时钟源频率必须在3倍波特率到4096倍波特率之间。\n对于CubeMX生成的工程，LPUART的时钟源默认为PCLK1（80M，STM32L4），因此其可以提供的最低频率为 80 * 10^6 / 4096 = 19532 bps。若要使用9600bps等低的波特率则应该首先修改 Clock Configuration 中的 LPUART 的时钟源为 HSI(16M)：\n此时，允许的波特率范围为3907bps~5.33Mbps。\n中断方式 CubeMX 配置 选中需要的 UART，Mode 选择 Asynchronous，即异步通信方式；NVIC Settings 中勾选 global interrupt 并设置优先级。选择好对应的 GPIO 引脚后就可以生成工程了。\n代码 参考 ST 固件库例程 USART_Communication_Rx_IT5、USART_Communication_Tx_IT6。\n定义结构体 UartITModel 1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { volatile uint8_t rxFlag; // 接收完一帧数据标志位 uint8_t rxLen; // 当前数据帧长度 uint8_t rxData[10]; // 当前数据 uint8_t _rx_data_index; // 下一个要接收的字节存放的数组下标 volatile uint8_t txBusy; // 0: 串口没有数据帧正在发送; 1: 有数据帧正在发送 uint8_t txLen; // 待发送的数据总长度 uint8_t txData[10]; // 待发送的数据 uint8_t _tx_data_index; // 下一个要发送的字节的数组下标 } UartITModel_1010; 1 UartITModel_1010 Lpuart1ITModel = {0}; 1 extern UartITModel_1010 Lpuart1ITModel; 配置串口接收中断 生成的代码默认会使能串口中断，但并不会开启串口的发送或接收等中断：\n添加并调用以下函数使能RXNE中断：\n1 2 3 4 5 6 7 8 9 10 void LPUART1_ITConfig(void); void LPUART1_ITConfig(void) { // if (LL_LPUART_IsActiveFlag_RXNE(LPUART1) == 1) // sometimes rxne is set after initialization // { // LL_LPUART_ReceiveData8(LPUART1); // clear rxne // } LL_LPUART_EnableIT_RXNE(LPUART1); /* Enable RXNE interrupts */ } 串口中断函数（RXNE） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @brief This function handles LPUART1 global interrupt. */ void LPUART1_IRQHandler(void) { /* USER CODE BEGIN LPUART1_IRQn 0 */ if ((LL_USART_IsEnabledIT_RXNE(LPUART1) == 1) \u0026amp;\u0026amp; (LL_USART_IsActiveFlag_RXNE(LPUART1) == 1)) // 接收到数据 { /* Read Received character. RXNE flag is cleared by reading of RDR register */ uint8_t rxdata = LL_USART_ReceiveData8(LPUART1); Lpuart1ITModel.rxData[Lpuart1ITModel._rx_data_index++] = rxdata; // data condition or rx array full if ((rxdata == 0xFF) || (Lpuart1ITModel._rx_data_index == sizeof(Lpuart1ITModel.rxData))) { Lpuart1ITModel.rxLen = Lpuart1ITModel._rx_data_index; Lpuart1ITModel._rx_data_index = 0; Lpuart1ITModel.rxFlag = 1; } } /* USER CODE END LPUART1_IRQn 0 */ /* USER CODE BEGIN LPUART1_IRQn 1 */ /* USER CODE END LPUART1_IRQn 1 */ } 发送数据 使用串口中断发送数据只需要开启 TXE 中断，在中断中依次将需要发送的数据写入 TDR 寄存器即可；写入最后一个字节后可以关闭 TXE 中断；但此时最后一个字节还没有被串口发送出去，需要开启 TC 中断以确保最后一字节数据被串口发送完成。\n1 2 3 4 5 6 7 8 9 10 11 12 void LPUART1_SendArrayIT(uint8_t *parr, uint8_t len); void LPUART1_SendArrayIT(uint8_t *parr, uint8_t len) { while (Lpuart1ITModel.txBusy == 1); // waiting last transmit Lpuart1ITModel.txBusy = 1; Lpuart1ITModel._tx_data_index = 0; Lpuart1ITModel.txLen = len; memcpy(Lpuart1ITModel.txData, parr, len); LL_LPUART_EnableIT_TXE(LPUART1); // enable tdr empty it } 串口中断函数（TX） 当 收到 0xff 或接收缓冲区满 时，产生数据帧接收完成标志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * @brief This function handles LPUART1 global interrupt. */ void LPUART1_IRQHandler(void) { /* USER CODE BEGIN LPUART1_IRQn 0 */ if ((LL_LPUART_IsEnabledIT_TXE(LPUART1) == 1) \u0026amp;\u0026amp; (LL_LPUART_IsActiveFlag_TXE(LPUART1) == 1)) // TDR 发送寄存器空 可以放入数据发送 写DR寄存器即清空标志位 { if (Lpuart1ITModel._tx_data_index == Lpuart1ITModel.txLen - 1) { LL_LPUART_DisableIT_TXE(LPUART1); // 关闭发送寄存器空中断 LL_LPUART_EnableIT_TC(LPUART1); // 使能发送完成中断 } LL_LPUART_TransmitData8(LPUART1, Lpuart1ITModel.txData[Lpuart1ITModel._tx_data_index++]); // 写寄存器 } if ((LL_LPUART_IsEnabledIT_TC(LPUART1) == 1) \u0026amp;\u0026amp; (LL_LPUART_IsActiveFlag_TC(LPUART1) == 1)) { LL_LPUART_ClearFlag_TC(LPUART1); /* Clear TC flag */ Lpuart1ITModel.txBusy = 0; } /* USER CODE END LPUART1_IRQn 0 */ /* USER CODE BEGIN LPUART1_IRQn 1 */ /* USER CODE END LPUART1_IRQn 1 */ } main 以回环应用为例，将串口接收缓冲区的数据发送出去：\n1 LPUART1_SendArrayIT(Lpuart1ITModel.rxData, Lpuart1ITModel.rxLen); DMA 方式 借助 DMA，可以使得串口进行连续通信。将串口寄存器的 DMAT 和 DMAR 位 置1可以使用 DMA 方式收发串口数据7。对应的库函数为：\n1 2 void LL_LPUART_EnableDMAReq_TX(USART_TypeDef *LPUARTx); /* Enable DMA Mode for transmission */ void LL_LPUART_EnableDMAReq_RX(USART_TypeDef *LPUARTx); /* Enable DMA Mode for reception */ DMA 寄存器 TCIFx: channle x 传输完成 HTIFx: channel x 传输一半 CNDTRx: 需要传输的数据数量；只有 DMA 通道 disabled 时才可以写入数据；当对应通道被启用时，该寄存器变成只读，表示待传输数据的剩余个数。每次 DMA 传输后，该寄存器值递减；当 DMA 工作于 Normal 模式时，传输完成后该寄存器保持为 0；Circular 模式时，该寄存器在传输完成后自动重置为上次设置的值。 发送流程 使用 DMA 发送串口数据的过程：当串口的 TXE 被置1时，DMA 将数据从 SRAM 加载到 TDR 寄存器。其具体配置过程如下7：\n配置 DMA 传输的目的地址为TDR寄存器地址（每次 TXE 置1时数据都会从存储区加载到 TDR 寄存器中）。 配置 DMA 传输的源地址为数据地址（每次 TXE 置1时数据都会从该地址加载到 TDR 寄存器中）。 配置 DMA 传输的总字节数（发送数据字节个数）。 配置 DMA 通道的优先级。 配置 DMA 传输完成/一半中断。 清除串口寄存器的 TC 标志位。（如果使能 DMA 传输之前就使能了 TC 中断，则会立刻进入中断；若等到 DMA 传输完成后再使能 TC 中断，则可以不在这一步清除标志位。） 激活 DMA 的对应通道。 当 DMA 传输的数据量到达设定的数据量时（数据被传送到 TDR 寄存器），产生中断 TCIF，但此时最后一个数据仍未被串口发送完成；若要禁止 UART 或进入停止模式前应监视串口的 TC 标志位以确保 UART 通信操作已经完成。\n接收流程 使用 DMA 接收串口数据的过程：当串口的 RXNE 被置1时，DMA 将数据从 RDR 寄存器加载到 SRAM。其具体配置与发送过程类似7。\nCubeMX 配置 DMA Settings 中添加 TX 和 RX；TX 的 Mode 选择 Normal，即发送一次自动停止，需要重新配置数据地址与长度；RX 的 Mode 选择 Circular，连续接收。\n勾选 NVIC Settings 中的 global interrupt。\n调整 Project Manager 中 Advanced Settings，移动初始化函数的调用顺序，确保 MX_DMA_Init 在 MX_xxx_UART_Init 之前，否则无法进入 DMA 传输过程8。\n代码 参考：USART_Communication_TxRx_DMA9、一个严谨的STM32串口DMA发送\u0026amp;接收（1.5Mbps波特率）机制10、usart_rx_idle_line_irq_L411\n定长接收 若要在 DMA 不支持双缓冲的情况下实现数据双缓冲定长接收，可以结合 DMA 的 HT 中断实现，此时结构体中的 rxData （DMA 接收缓冲区）数组长度应为数据长度的一半，防止处理数据不及时一些数据被下一次 DMA 传输覆盖。\n定义结构体 UartDMAFixModel 1 2 3 4 5 6 7 8 9 10 typedef struct { volatile uint8_t rxFlag; // 接收完一帧数据标志位 1: 接收完成 uint8_t rxLen; // 定长数据帧长度, _rx_dma_data 的一半 uint8_t _rx_dma_data[20]; // DMA 接收数据缓冲区，定长接收每次只处理一半数据 uint8_t *rxDataPointer; // 指向当前可以处理的数据的首地址, 在 DMA 中断切换地址 volatile uint8_t txBusy; // 0: 串口没有数据帧正在发送; 1: 有数据帧正在发送 uint8_t txData[10]; // 需要发送的数据，同时也是 DMA 发送的缓冲区 } UartDMAFixModel_1010; 1 2 3 4 5 6 7 8 9 10 UartDMAFixModel_1010 Lpuart1DMAFixModel = { .rxFlag = 0, .rxLen = sizeof(Lpuart1DMAFixModel._rx_dma_data) / 2, ._rx_dma_data = {0}, .rxDataPointer = NULL, .txBusy = 0, .txData = {0} }; 1 extern UartDMAFixModel_1010 Lpuart1DMAFixModel; 配置串口 DMA 地址、长度、中断 CubeMX 生成的代码并不会配置 DMA 的外设和存储器地址、数据长度以及相应的传输中断；编写并调用下列代码以设定串口 TX 和 RX 的 DMA 相应配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @brief extra config LPUART1 TX RX Variable length data reception use DMA * @param None * @retval None */ void LPUART1_DMAFixConfig(void) { LL_DMA_SetPeriphAddress(DMA2, LL_DMA_CHANNEL_6, LL_LPUART_DMA_GetRegAddr(LPUART1, LL_LPUART_DMA_REG_DATA_TRANSMIT)); // tx dma dest address LL_DMA_EnableIT_TC(DMA2, LL_DMA_CHANNEL_6); // tx dma transfer complete interrupt // rx dma source address and dest address and length LL_DMA_SetPeriphAddress(DMA2, LL_DMA_CHANNEL_7, LL_LPUART_DMA_GetRegAddr(LPUART1, LL_LPUART_DMA_REG_DATA_RECEIVE)); LL_DMA_SetMemoryAddress(DMA2, LL_DMA_CHANNEL_7, (uint32_t)Lpuart1DMAFixModel._rx_dma_data); LL_DMA_SetDataLength(DMA2, LL_DMA_CHANNEL_7, sizeof(Lpuart1DMAFixModel._rx_dma_data)); LL_DMA_EnableIT_TC(DMA2, LL_DMA_CHANNEL_7); // rx dma transfer complete interrupt LL_DMA_EnableIT_HT(DMA2, LL_DMA_CHANNEL_7); // rx dma half transfer interrupt LL_DMA_EnableChannel(DMA2, LL_DMA_CHANNEL_7); // enable uart dma rx LL_LPUART_EnableDMAReq_TX(LPUART1); // enable dma to handle uart tdr LL_LPUART_EnableDMAReq_RX(LPUART1); // enable dma to handle uart rdr } DMA 中断函数（HT TC） 使用 DMA 的传输完成中断和传输半完成中断可以方便的进行串口数据的定长接收；根据不同的 DMA 标志位设定指向当前可以处理的数据的首地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * @brief This function handles DMA2 channel7 global interrupt. */ void DMA2_Channel7_IRQHandler(void) { /* USER CODE BEGIN DMA2_Channel7_IRQn 0 */ // lpuart1 rx if (LL_DMA_IsEnabledIT_HT(DMA2, LL_DMA_CHANNEL_7) \u0026amp;\u0026amp; LL_DMA_IsActiveFlag_HT7(DMA2)) { LL_DMA_ClearFlag_HT7(DMA2); // TODO: uart rx dma half transfer Lpuart1DMAFixModel.rxDataPointer = Lpuart1DMAFixModel._rx_dma_data + 0; Lpuart1DMAFixModel.rxFlag = 1; } if (LL_DMA_IsEnabledIT_TC(DMA2, LL_DMA_CHANNEL_7) \u0026amp;\u0026amp; LL_DMA_IsActiveFlag_TC7(DMA2)) { LL_DMA_ClearFlag_TC7(DMA2); // TODO: uart rx dma transfer complete Lpuart1DMAFixModel.rxDataPointer = Lpuart1DMAFixModel._rx_dma_data + Lpuart1DMAFixModel.rxLen; Lpuart1DMAFixModel.rxFlag = 1; } /* USER CODE END DMA2_Channel7_IRQn 0 */ /* USER CODE BEGIN DMA2_Channel7_IRQn 1 */ /* USER CODE END DMA2_Channel7_IRQn 1 */ } 重置 DMA 接收长度 对于定长数据的接收，数据接收完成是靠 DMA 的传输一半或传输完成标志位判断的；若某次通信时，数据帧的一个字节丢失，则会导致后续的数据全部错位，从而无法正确解析。因此在数据处理之前需要通过校验帧头或者校验和等方式判断数据是否有效；当前数据帧错误时，对于下一帧数据应重新从 DMA 数组的第一个元素开始接收。\n下面假设数据帧头必须为 0x55，校验成功时，将收到的一帧数据通过串口发回；当数据帧校验失败时，关闭 DMA 接收通道并重置 DMA 接收数据长度，同时打开串口空闲中断，等待当前数据帧全部发送完成后重新打开 DMA 接收通道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Verify data frames and parse data * @param pdata pointer to the first data * @retval 1: verify success; 0: verify fail */ uint8_t Lpurat1DataProcess(uint8_t *pdata) { uint8_t dataValid = 0; // Verify data frame if (pdata[0] != 0x55) // example: frame header must be 0x55 { dataValid = 0; } else { dataValid = 1; } if (dataValid == 0) { // The data may be misaligned // reset dma rx length // 1st: disable dma rx channel LL_DMA_DisableChannel(DMA2, LL_DMA_CHANNEL_7); // 2nd: reset data length so that new transfer can be placed into the first array element LL_DMA_SetDataLength(DMA2, LL_DMA_CHANNEL_7, sizeof(Lpuart1DMAFixModel._rx_dma_data)); // 3rd: enable uart rx idle it, When the current full data frame transmission is complete, re-enable DMA reception. LL_LPUART_EnableIT_IDLE(LPUART1); // 4th: (in the function UART IRQHandler) return 0; } // TODO: data parsing LPUART1_SendArrayDMA(pdata, Lpuart1DMAFixModel.rxLen); // ... return 1; } 串口空闲中断处理过程：清除空闲标志位、关闭串口空闲中断、重新开启 DMA 接收通道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @brief This function handles LPUART1 global interrupt. */ void LPUART1_IRQHandler(void) { /* USER CODE BEGIN LPUART1_IRQn 0 */ if ((LL_LPUART_IsEnabledIT_IDLE(LPUART1) == 1) \u0026amp;\u0026amp; (LL_LPUART_IsActiveFlag_IDLE(LPUART1) == 1)) { LL_LPUART_ClearFlag_IDLE(LPUART1); // 1st-3rd: (in the function Lpurat1DataProcess()) // 4th: disable idle it and re-enable DMA reception. LL_LPUART_DisableIT_IDLE(LPUART1); LL_DMA_EnableChannel(DMA2, LL_DMA_CHANNEL_7); } /* USER CODE END LPUART1_IRQn 0 */ /* USER CODE BEGIN LPUART1_IRQn 1 */ /* USER CODE END LPUART1_IRQn 1 */ } main 收到数据后，调用数据处理函数。\n1 2 3 4 5 6 7 8 9 10 if (Lpuart1DMAFixModel.rxFlag == 1) // HT or TC { uint8_t verifyResult = Lpurat1DataProcess(Lpuart1DMAFixModel.rxDataPointer); if (verifyResult == 0) { // TODO: check verifyResult // ... } Lpuart1DMAFixModel.rxFlag = 0; } 不定长接收 定义结构体 UartDMAVarModel 结构体中的 rxData 最好比最长的数据帧多几个字节，防止处理数据不及时一些数据被下一次 DMA 传输覆盖。\n1 2 3 4 5 6 7 8 9 10 11 typedef struct { volatile uint8_t rxFlag; // 接收完一帧数据标志位 uint8_t rxLen; // 当前数据帧长度 uint8_t rxData[10]; // 当前数据 uint8_t _rx_dma_data[10]; // DMA 接收缓冲区 uint8_t _rx_dma_last_used; // 上一帧数据传输完成时DMA的使用量 volatile uint8_t txBusy; // 0: 串口没有数据帧正在发送; 1: 有数据帧正在发送 uint8_t txData[10]; // 需要发送的数据，同时也是 DMA 发送的缓冲区 } UartDMAVarModel_1010; 1 UartDMAVarModel_1010 Lpuart1DMAVarModel = {0}; 1 extern UartDMAVarModel_1010 Lpuart1DMAVarModel; 配置串口 DMA 地址、长度、中断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void LPUART1_DMAVarConfig(void); /** * @brief extra config LPUART1 TX RX use DMA * @param None * @retval None */ void LPUART1_DMAVarConfig(void) { // tx dma dest address LL_DMA_SetPeriphAddress(DMA2, LL_DMA_CHANNEL_6, LL_LPUART_DMA_GetRegAddr(LPUART1, LL_LPUART_DMA_REG_DATA_TRANSMIT)); // enable dma tx transfer complete interrupt LL_DMA_EnableIT_TC(DMA2, LL_DMA_CHANNEL_6); // rx dma source address and dest address and length LL_DMA_SetPeriphAddress(DMA2, LL_DMA_CHANNEL_7, LL_LPUART_DMA_GetRegAddr(LPUART1, LL_LPUART_DMA_REG_DATA_RECEIVE)); LL_DMA_SetMemoryAddress(DMA2, LL_DMA_CHANNEL_7, (uint32_t)Lpuart1DMAVarModel._rx_dma_data); LL_DMA_SetDataLength(DMA2, LL_DMA_CHANNEL_7, sizeof(Lpuart1DMAVarModel._rx_dma_data)); // no need to enable dma rx tc and ht interrupt // enable uart dma rx LL_DMA_EnableChannel(DMA2, LL_DMA_CHANNEL_7); // enable uart idle interrupt LL_LPUART_ClearFlag_IDLE(LPUART1); LL_LPUART_EnableIT_IDLE(LPUART1); LL_LPUART_EnableDMAReq_TX(LPUART1); // enable dma to handle uart tdr LL_LPUART_EnableDMAReq_RX(LPUART1); // enable dma to handle uart rdr } 串口中断函数（IDLE ） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /** * @brief This function handles LPUART1 global interrupt. */ void LPUART1_IRQHandler(void) { /* USER CODE BEGIN LPUART1_IRQn 0 */ if ((LL_LPUART_IsEnabledIT_IDLE(LPUART1) == 1) \u0026amp;\u0026amp; (LL_LPUART_IsActiveFlag_IDLE(LPUART1) == 1)) { LL_LPUART_ClearFlag_IDLE(LPUART1); uint8_t dmaTransedLen = sizeof(Lpuart1DMAVarModel._rx_dma_data) - LL_DMA_GetDataLength(DMA2, LL_DMA_CHANNEL_7); // 当前 DMA 已传输数量 if (dmaTransedLen \u0026gt; Lpuart1DMAVarModel._rx_dma_last_used) // 本次数据帧传输跨过了 DMA 数组末尾 { /* * Processing is done in \u0026#34;linear\u0026#34; mode. * * Application processing is fast with single data block, * length is simply calculated by subtracting pointers * * [ 0 ] * [ 1 ] \u0026lt;- _rx_dma_last_used |-----------------------------------------| * [ 2 ] | Single block | * [ 3 ] | len = dmaTransedLen - _rx_dma_last_used | * [ 4 ] | | * [ 5 ] |-----------------------------------------| * [ 6 ] \u0026lt;- dmaTransedLen * [ 7 ] * [N - 1] */ // 本次传输量 = 当前DMA已传输量 - 上次传输后剩余的DMA数量 Lpuart1DMAVarModel.rxLen = dmaTransedLen - Lpuart1DMAVarModel._rx_dma_last_used; // 拷贝 DMA 数据 memcpy(Lpuart1DMAVarModel.rxData, Lpuart1DMAVarModel._rx_dma_data + Lpuart1DMAVarModel._rx_dma_last_used, Lpuart1DMAVarModel.rxLen); } else { /* * Processing is done in \u0026#34;overflow\u0026#34; mode.. * * Application must process data twice, * since there are 2 linear memory blocks to handle * * [ 0 ] |------------------------------------| * [ 1 ] | 2nd block (len = dmaTransedLen) | * [ 2 ] |------------------------------------| * [ 3 ] \u0026lt;- dmaTransedLen * [ 4 ] \u0026lt;- _rx_dma_last_used |------------------------------------| * [ 5 ] | 1st block | * [ 6 ] | len = N - _rx_dma_last_used | * [ 7 ] | | * [N - 1] |------------------------------------| */ // 本次传输量 = 上次传输后剩余的DMA数量 + 当前DMA已传输量 Lpuart1DMAVarModel.rxLen = (sizeof(Lpuart1DMAVarModel._rx_dma_data) - Lpuart1DMAVarModel._rx_dma_last_used) + dmaTransedLen; // 先拷贝上次传输后剩余的 DMA 数组 rxData \u0026lt;- _rx_dma_data[_rx_dma_last_used] memcpy(Lpuart1DMAVarModel.rxData, Lpuart1DMAVarModel._rx_dma_data + Lpuart1DMAVarModel._rx_dma_last_used/* base */, sizeof(Lpuart1DMAVarModel._rx_dma_data) - Lpuart1DMAVarModel._rx_dma_last_used ); // 再拷贝本次 DMA 传输的用量 memcpy(Lpuart1DMAVarModel.rxData + (sizeof(Lpuart1DMAVarModel._rx_dma_data) - Lpuart1DMAVarModel._rx_dma_last_used), Lpuart1DMAVarModel._rx_dma_data, dmaTransedLen ); } Lpuart1DMAVarModel._rx_dma_last_used = dmaTransedLen; Lpuart1DMAVarModel.rxFlag = 1; } /* USER CODE END LPUART1_IRQn 0 */ /* USER CODE BEGIN LPUART1_IRQn 1 */ /* USER CODE END LPUART1_IRQn 1 */ } main 以回环应用为例，当接收到一帧数据后把数据发回。\n1 2 3 4 5 if (Lpuart1DMAVarModel.rxFlag == 1) { LPUART1_SendArrayDMA(Lpuart1DMAVarModel.rxData, Lpuart1DMAVarModel.rxLen); Lpuart1DMAVarModel.rxFlag = 0; } 发送 下面以定长接收的结构体为例，给出使用 DMA 进行串口数据发送的代码。DMA 的初始化过程已经在接收的配置中顺便配置过了。\n发送数据 1 2 3 4 5 6 7 8 9 10 11 12 13 void LPUART1_SendArrayDMA(uint8_t *parr, uint8_t len); void LPUART1_SendArrayDMA(uint8_t *parr, uint8_t len) { while (Lpuart1DMAVarModel.txBusy == 1); // wait last data transfer complete Lpuart1DMAVarModel.txBusy = 0; memcpy(Lpuart1DMAVarModel.txData, parr, len); LL_DMA_SetMemoryAddress(DMA2, LL_DMA_CHANNEL_6, (uint32_t)Lpuart1DMAVarModel.txData); // tx dma mem address LL_DMA_SetDataLength(DMA2, LL_DMA_CHANNEL_6, len); // tx dma length LL_DMA_EnableChannel(DMA2, LL_DMA_CHANNEL_6); } DMA 中断函数（TC） DMA 的传输完成中断 TC 只能代表把所有待发送的数据都传输到了串口的 TDR 寄存器中，但是此时最后一字节数据并没有被串口发送完成；应开启串口发送完成中断判断数据全部发送完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @brief This function handles DMA2 channel6 global interrupt. */ void DMA2_Channel6_IRQHandler(void) { /* USER CODE BEGIN DMA2_Channel6_IRQn 0 */ // lpuart1 tx if(LL_DMA_IsEnabledIT_TC(DMA2, LL_DMA_CHANNEL_6) \u0026amp;\u0026amp; LL_DMA_IsActiveFlag_TC6(DMA2)) { LL_DMA_ClearFlag_TC6(DMA2); LL_DMA_DisableChannel(DMA2, LL_DMA_CHANNEL_6); LL_LPUART_EnableIT_TC(LPUART1); } /* USER CODE END DMA2_Channel6_IRQn 0 */ /* USER CODE BEGIN DMA2_Channel6_IRQn 1 */ /* USER CODE END DMA2_Channel6_IRQn 1 */ } 串口中断函数（TC） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief This function handles LPUART1 global interrupt. */ void LPUART1_IRQHandler(void) { /* USER CODE BEGIN LPUART1_IRQn 0 */ if ((LL_LPUART_IsEnabledIT_TC(LPUART1) == 1) \u0026amp;\u0026amp; (LL_LPUART_IsActiveFlag_TC(LPUART1) == 1)) { LL_LPUART_ClearFlag_TC(LPUART1); /* Clear TC flag */ Lpuart1DMAVarModel.txBusy = 0; } /* USER CODE END LPUART1_IRQn 0 */ /* USER CODE BEGIN LPUART1_IRQn 1 */ /* USER CODE END LPUART1_IRQn 1 */ } References RM0090_STM32F405415,407417,427437,429439_ReferenceManual | 30.3 USART functional description | p.968\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRM0351 Reference manual STM32L47xxx, STM32L48xxx, STM32L49xxx and STM32L4Axxx advanced Arm®-based 32-bit MCUs | 40.5.1 USART character description | p.1344-1345\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRM0351 Reference manual STM32L47xxx, STM32L48xxx, STM32L49xxx and STM32L4Axxx advanced Arm®-based 32-bit MCUs | 40.5.3 USART receiver | p.1350\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRM0351 Reference manual STM32L47xxx, STM32L48xxx, STM32L49xxx and STM32L4Axxx advanced Arm®-based 32-bit MCUs | 41.4.4 LPUART baud rate generation | p.1419\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSTM32Cube_FW_L4_V1.17.0\\Projects\\NUCLEO-L496ZG\\Examples_LL\\USART\\USART_Communication_Rx_IT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSTM32Cube_FW_L4_V1.17.0\\Projects\\NUCLEO-L496ZG\\Examples_LL\\USART\\USART_Communication_Tx_IT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRM0351 Reference manual STM32L47xxx, STM32L48xxx, STM32L49xxx and STM32L4Axxx advanced Arm®-based 32-bit MCUs | 41.4.9 Continuous communication in DMA mode using LPUART | p.1425\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCUBEMX生成代码需要注意顺序，折腾STM32+ADC+DMA | CSDN | ricefat609\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSTM32Cube_FW_L4_V1.17.0\\Projects\\NUCLEO-L496ZG\\Examples_LL\\USART\\USART_Communication_TxRx_DMA\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n一个严谨的STM32串口DMA发送\u0026amp;接收（1.5Mbps波特率）机制 | CSDN | Acuity.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nusart_rx_idle_line_irq_L4 | Github | MaJerle\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fivekernels.github.io/posts/stm32-uart-ll/","summary":"UART 框图 查看芯片对应的 Reference Manual 的 USART/UART 章节可以找到其框图。以 F4 系列的参考手册为例，其框图如下1： 可以看出，对于发送的数据，依次经过 TDR 寄存器 -\u0026gt; 发送移位寄","title":"STM32 UART LL Library"},{"content":"安装 sftp 如果 OpenWrt 不支持使用 Xftp 等软件进行传输文件时，需要手动安装 openssh-sftp-server。1 2\n1 2 3 4 opkg update opkg install openssh-sftp-server /etc/init.d/vsftpd enable /etc/init.d/vsftpd start 启用 SSL OpenWrt 使用 uhttpd 作为web服务器，配置文件为 /etc/config/uhttpd；可以使用vi修改其配置，并上传ssl证书到配置的路径下。\n此外，uhttpd 默认禁止通过外网访问路由器界面，如果要取消限制同样需要修改配置文件option rfc1918_filter \u0026lsquo;0\u0026rsquo;。\n1 2 3 4 5 6 7 8 config uhttpd \u0026#39;main\u0026#39; # ... list listen_https \u0026#39;0.0.0.0:443\u0026#39; list listen_https \u0026#39;[::]:443\u0026#39; option rfc1918_filter \u0026#39;0\u0026#39; # disable rfc1918 filter option redirect_https \u0026#39;1\u0026#39; # redirect http to https option cert \u0026#39;/etc/ssl/\u0026lt;domain\u0026gt;/\u0026lt;fullchain\u0026gt;.crt\u0026#39; # crt file option key \u0026#39;/etc/ssl/\u0026lt;domain\u0026gt;/\u0026lt;privkey\u0026gt;.key\u0026#39; # key file 重启 uhttpd 服务：\n1 /etc/init.d/uhttpd restart web 登录页面不显示用户名 OpenWrt 默认的登录页面会显示默认的用户名 root，如果更改了用户名或者为了安全考虑不想把他显示出来可以修改一下 luci 的 html 文件 /usr/lib/lua/luci/view/sysauth.htm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- ... --\u0026gt; \u0026lt;div class=\u0026#34;cbi-value-field\u0026#34;\u0026gt; - \u0026lt;input class=\u0026#34;cbi-input-user\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;luci_username\u0026#34; value=\u0026#34;\u0026lt;%=duser%\u0026gt;\u0026#34; /\u0026gt; + \u0026lt;input class=\u0026#34;cbi-input-user\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;luci_username\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;//\u0026lt;![CDATA[ -var input = document.getElementsByName(\u0026#39;luci_password\u0026#39;)[0]; +var input = document.getElementsByName(\u0026#39;luci_username\u0026#39;)[0]; if (input) input.focus(); //]]\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ... --\u0026gt; ipv6 to ipv4 端口转发 虽然 ipv6 时代每个设备都可以获得独立的公网 ipv6 地址，但是要直接解析到设备的 ip 需要对每个设备分别做 ddns ；且由于每个设备获取到的 ipv6 地址个数很多，机制也很复杂，我还没研究明白，所以直接只对路由器的ipv6做ddns再通过端口转发到局域网的设备是个比较容易的解决方案。\nOpenWrt 下使用 socat 可以实现从公网 ipv6 到 内网 ipv4 的转发。\n1 2 opkg update opkg install socat 编写配置文件 配置文件为 /etc/config/socat。例如下列的配置分别将 ipv6 的端口 1234 、5678 转发到 192.168.1.100:9012 和 192.168.1.200:1314。3\n1 2 3 4 5 6 7 config socat \u0026#39;1234\u0026#39; option enable \u0026#39;1\u0026#39; option SocatOptions \u0026#39;-d -d TCP6-LISTEN:1234,fork TCP4:192.168.1.100:9012\u0026#39; config socat \u0026#39;5678\u0026#39; option enable \u0026#39;1\u0026#39; option SocatOptions \u0026#39;-d -d TCP6-LISTEN:5678,fork TCP4:92.168.1.200:1314\u0026#39; 应该也可以使用命令行添加，没试过。\n1 2 3 4 uci set socat.1234=\u0026#39;socat\u0026#39; uci set socat.1234.enabled=\u0026#39;1\u0026#39; uci set socat.1234.SocatOptions=\u0026#39;-d -d TCP6-LISTEN:1234,fork TCP4:192.168.1.100:9012\u0026#39; uci commit socat 启动 socat 服务：\n1 2 /etc/init.d/socat enabled /etc/init.d/socat start 防火墙放行对应端口 打开 OpenWrt -\u0026gt; 网络 -\u0026gt; 防火墙 -\u0026gt; 通信规则，按照如下设置：\n其中，目标区域应选择设备（输入），目标端口输入上面配置的需要被转发的 ipv6 端口，高级设置中限制地址类型选择仅IPv6（IPv4的端口转发在防火墙的端口转发下设置）。设置完成后，如下图所示。\nDDNS 自启动 如果遇到 ddns 在系统启动或网络中断后进程没有启动，可以创建如下脚本进行定时检测：4\n编写进程监控脚本 在任意位置放置脚本文件 ddns_monitor.sh，并配置权限 0755 或 0777\n1 2 3 4 5 6 7 8 9 logger \u0026#34;DDNS Checking Start !\u0026#34; num=`ps | grep dynamic_dns_updater | grep -v grep | grep -v check | wc -l` # 计算进程数 if [ $num -lt 2 ] # 判断进程是否存在，根据创建的ddns个数修改 then /etc/init.d/ddns restart #echo \u0026#34;------------ddns start------------\u0026#34; logger \u0026#34;ddns start\u0026#34; fi #printf \u0026#34;------------------------DDNS Checking Over !---------------------------\\n\u0026#34; 1 chmod 777 ddns_monitor.sh 创建定时任务 在 OpenWrt 中的系统 -\u0026gt; 计划任务中添加一行，实现每隔15分钟检查以下ddns进程还在不在\n1 */15 * * * * sh \u0026lt;path\u0026gt;/ddns_monitor.sh References Openwrt SSH服务端支持Sftp | Daniel Sun\u0026rsquo;s Blog\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOpenWrt开启sftp，方便传输文件 | CSDN | bytxl\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nopenwrt ipv6如何端口转发？| 恩山无线论坛 | 99010\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n解决”动态DNS“开机不会自动更新和启动进程功能的失效问题 | 恩山无线论坛 | 野马joe\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fivekernels.github.io/posts/openwrt-configuration/","summary":"安装 sftp 如果 OpenWrt 不支持使用 Xftp 等软件进行传输文件时，需要手动安装 openssh-sftp-server。1 2 1 2 3 4 opkg update opkg install openssh-sftp-server /etc/init.d/vsftpd enable /etc/init.d/vsftpd start 启用 SSL OpenWrt 使用","title":"OpenWrt Configuration"},{"content":" 本文介绍了在树莓派(aarch64)上使用docker的方式配置nextcloud:fpm、mariadb、nginx、redis以及onlyoffice。\nNextcloud官方手册中有数据库等各种镜像版本推荐https://docs.nextcloud.com/server/latest/admin_manual/installation/system_requirements.html，最好不要使用过于新的版本以免出现未被解决的兼容性问题。\nNextcloud版本介绍：\nnextcloud:latest：默认最新版本，新手友好。使用debian容器搭建，自带apache web服务，特点就是简单方便，一键部署就可以使用，缺点就是包略大。 nextcloud:fpm：在debian容器的基础上不带apache web服务，需要配套web程序才能使用，如NGINX。 nextcloud:\u0026lt;version\u0026gt;-alpine：使用alpine作为容器，空间占据少，适合小主机使用。 docker-compose docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 version: \u0026#39;3\u0026#39; services: nextcloud: hostname: nextcloud image: nextcloud:fpm container_name: nextcloud_nextcloud restart: unless-stopped volumes: - ./PersistentData/nextcloud:/var/www/html env_file: - ./nextcloud.env depends_on: - mariadb - redis mariadb: hostname: mariadb image: mariadb container_name: nextcloud_mariadb restart: unless-stopped command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --transaction-isolation=READ-COMMITTED --binlog-format=ROW --innodb_read_only_compressed=OFF volumes: - ./PersistentData/mariadb:/var/lib/mysql env_file: - ./mariadb.env nginx: hostname: nginx image: nginx container_name: nextcloud_nginx restart: unless-stopped volumes: - ./config/nginx/nginx.conf:/etc/nginx/nginx.conf:ro - ./config/ssl/\u0026lt;example.domain\u0026gt;/fullchain.pem:/etc/ssl/nginx/fullchain.pem - ./config/ssl/\u0026lt;example.domain\u0026gt;/privkey.pem:/etc/ssl/nginx/privkey.pem - ./PersistentData/nextcloud:/usr/share/nginx/html/nextcloud:ro ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; depends_on: - nextcloud redis: image: redis container_name: nextcloud_redis restart: unless-stopped cron: image: nextcloud:fpm container_name: nextcloud_cron restart: unless-stopped volumes: - ./PersistentData/nextcloud:/var/www/html entrypoint: /cron.sh depends_on: - mariadb - redis nextcloud.env 1 2 3 4 5 6 7 8 9 10 11 NEXTCLOUD_ADMIN_USER=\u0026lt;nextcloud_admin_user_to_be_created\u0026gt; NEXTCLOUD_ADMIN_PASSWORD=\u0026lt;nextcloud_admin_user_password_to_be_created\u0026gt; NEXTCLOUD_TRUSTED_DOMAINS=\u0026lt;example.domain\u0026gt; MYSQL_HOST=mariadb MYSQL_DATABASE=\u0026lt;nextcloud_database_to_be_used\u0026gt; MYSQL_USER=\u0026lt;nextcloud_database_user_to_be_used\u0026gt; MYSQL_PASSWORD=\u0026lt;nextcloud_database_user_password_to_be_used\u0026gt; REDIS_HOST=redis REDIS_HOST_PORT=6379 mariadb.env 1 2 3 4 5 MARIADB_ROOT_PASSWORD=\u0026lt;root_password\u0026gt; MARIADB_DATABASE=\u0026lt;nextcloud_database_to_be_created\u0026gt; MARIADB_USER=\u0026lt;nextcloud_database_user_to_be_created\u0026gt; MARIADB_PASSWORD=\u0026lt;nextcloud_database_user_password_to_be_created\u0026gt; MARIADB_AUTO_UPGRADE=1 docker-compose文件解析 在Nextcloud的官方docker页面https://hub.docker.com/_/nextcloud 有docker-compose的示例配置文件\nnextcloud-fpm Nextcloud中所有的数据文件存放在容器内的/var/www/html中，可以将其映射到外部存储。data和config文件存储在其中单独的文件夹，apps文件夹是随着nextcloud一起提供的，无需在意。\n使用环境变量可以第一次安装时自动配置相关设置，以使用MariaDB/MYSQL为例，配置数据库需要设置以下几个环境变量：\nMYSQL_HOST: Hostname of the database server using mysql / mariadb. MYSQL_DATABASE: Name of the database using mysql / mariadb. MYSQL_USER: Username for the database using mysql / mariadb. MYSQL_PASSWORD: Password for the database user using mysql / mariadb. 设置如下环境变量可以在安装nextcloud时自动配置管理员用户名和密码：\nNEXTCLOUD_ADMIN_USER: Name of the Nextcloud admin user. NEXTCLOUD_ADMIN_PASSWORD: Password for the Nextcloud admin user. 设置如下环境变量可以在安装时自动添加可信域名：\nNEXTCLOUD_TRUSTED_DOMAINS: (not set by default) Optional space-separated list of domains 如果使用了redis（推荐），还应添加下列变量指出redis服务器信息：\nREDIS_HOST (not set by default) Name of Redis container REDIS_HOST_PORT (default: 6379) Optional port for Redis, only use for external Redis servers that run on non-standard ports. REDIS_HOST_PASSWORD (not set by default) Redis password PHP相关限制：（未测试）\nPHP_MEMORY_LIMIT: (default 512M) This sets the maximum amount of memory in bytes that a script is allowed to allocate. This is meant to help prevent poorly written scripts from eating up all available memory but it can prevent normal operation if set too tight. PHP_UPLOAD_LIMIT: (default 512M) This sets the upload limit (post_max_size and upload_max_filesize) for big files. Note that you may have to change other limits depending on your client, webserver or operating system. Check the Nextcloud documentation for more information. 当然，可以使用_FILE替代直接在docke-compose设置环境变量以传递敏感信息。我没仔细看https://hub.docker.com/_/nextcloud\nmariadb mariadb的数据库文件位于容器内的/var/lib/mysql，可以将其映射到容器外部。\n当使用docker创建新数据库时，可以使用以下环境变量来调整MariaDB的初始化，从10.5.10和10.6开始以后的所有版本中，MARIADB_* 和 MYSQL_* 具有等效的功能，且MARIADB_*具有更高的优先级。\n下列四个环境变量(or equivalents, including *_FILE)必须设定一个，以确定roog用户密码：\nMARIADB_ROOT_PASSWORD: This specifies the password that will be set for the MariaDB root superuser account. MARIADB_ROOT_PASSWORD_HASH: In order to have no plaintext secret in the deployment, MARIADB_ROOT_PASSWORD_HASH can be used as it is just the hash of the password. The hash can be generated with SELECT PASSWORD(\u0026rsquo;thepassword\u0026rsquo;) as a SQL query. MARIADB_RANDOM_ROOT_PASSWORD: Set to a non-empty value, like yes, to generate a random initial password for the root user. The generated root password will be printed to stdout (GENERATED ROOT PASSWORD: \u0026hellip;..). MARIADB_ALLOW_EMPTY_ROOT_PASSWORD: Set to a non-empty value, like yes, to allow the container to be started with a blank password for the root user. 其他的环境变量（可选）：\nMARIADB_DATABASE: This variable allows you to specify the name of a database to be created on image startup. MARIADB_USER: These are used in conjunction to create a new user and to set that user\u0026rsquo;s password. This user will be granted all access (corresponding to GRANT ALL) to the MARIADB_DATABASE database. MARIADB_PASSWORD: Both user and password variables are required for a user to be created. MARIADB_PASSWORD_HASH: See MARIADB_ROOT_PASSWORD_HASH above for how to get a password hash for MARIADB_PASSWORD_HASH. MARIADB_AUTO_UPGRADE: Set MARIADB_AUTO_UPGRADE to a non-empty value to have the entrypoint check whether mysql_upgrade/mariadb-upgrade needs to run, and if so, run the upgrade before starting the MariaDB server. MARIADB_DISABLE_UPGRADE_BACKUP: Before the upgrade, a backup of the system database is created in the top of the datadir with the name system_mysql_backup_*.sql.zst. This backup process can be disabled with by setting MARIADB_DISABLE_UPGRADE_BACKUP to a non-empty value. nginx 编写配置文件nginx.conf并映射到容器内的/etc/nginx/nginx.conf，作为配置文件；同时还需要把nextcloud中的/var/www/html映射到nginx容器内部，作为网站内容。\nredis cron 官方文档中关于background jons的介绍：https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/background_jobs_configuration.html\n使用docker部署cron时，cron的运行需要一个独立的容器并和nextcloud共享数据文件，并且据说所占用的内存很少，不会为主机带来性能问题；可以参考官方示例中使用docker-compose运行cron的配置文件：https://github.com/nextcloud/docker/blob/master/.examples/docker-compose/insecure/mariadb/apache/docker-compose.yml。\n此外，还可以使用主机的cron并搭配docker exec命令实现定时的后台任务。\n更新nextcloud版本 当使用 docker-compose 时，更新容器的新版本只需要运行:\n1 2 docker-compose pull docker-compose up -d 但是不能跨越多个大版本升级，此时需要修改nextcloud:\u0026lt;version\u0026gt;-fpm指定大版本号进行以此升级。\nnextcloud 配置文件 nextcloud 支持使用多个config.php配置文件；可以在/var/www/html/config/路径下放置*.config.php文件实现对nextcloud的配置，且这些文件中配置的参数优先级高于config.php中的设定。\n1 2 3 4 5 6 \u0026lt;?php $CONFIG = array ( \u0026#39;remember_login_cookie_lifetime\u0026#39; =\u0026gt; 0, \u0026#39;default_phone_region\u0026#39; =\u0026gt; \u0026#39;CN\u0026#39;, \u0026#39;defaultapp\u0026#39; =\u0026gt; \u0026#39;calendar,files,dashboard\u0026#39;, ); remember_login_cookie_lifetime 记住登录 cookie 的生命周期，为0则关闭浏览器后cookie立即失效。\ndefault_phone_region 使用 ISO 3166-1 国家代码为 Nextcloud 服务器上的电话号码设置默认区域。\ndefaultapp 设置用户登录后首先进入的应用；参数为在点击Nextcloud顶部的“应用程序”菜单后，对应的URL名称，如 documents，calendar，gallery等。可以使用\u0026quot;,\u0026ldquo;分隔应用列表。设置多个应用名称时，如果用户没有进入列表中的第一个应用程序（如列表中的第一个应用没启用），则 Nextcloud 将尝试使用户进入第二个应用程序，依此类推。如果 Nextcloud 没有找到已启用的应用程序，则默认为仪表板应用程序。\nnginx 配置文件 nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 worker_processes auto; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; upstream php-handler { server nextcloud:9000; } server { listen 80; listen [::]:80; #server_name nextcloud.example.com; server_name \u0026lt;example.domain\u0026gt;; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; #server_name nextcloud.example.com; server_name \u0026lt;example.domain\u0026gt;; error_page 497 =301 https://$http_host$request_uri; ssl_certificate /etc/ssl/nginx/fullchain.pem; ssl_certificate_key /etc/ssl/nginx/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256; ssl_prefer_server_ciphers on; ssl_ecdh_curve secp384r1; # HSTS settings # WARNING: Only add the preload option once you read about # the consequences in https://hstspreload.org/. This option # will add the domain to a hardcoded list that is shipped # in all major browsers and getting removed from this list # could take several months. add_header Strict-Transport-Security \u0026#34;max-age=15768000; includeSubDomains; preload;\u0026#34; always; # set max upload size client_max_body_size 100G; fastcgi_buffers 64 4K; fastcgi_send_timeout 300s; fastcgi_read_timeout 300s; # Enable gzip but do not remove ETag headers gzip on; gzip_vary on; gzip_comp_level 4; gzip_min_length 256; gzip_proxied expired no-cache no-store private no_last_modified no_etag auth; gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # Pagespeed is not supported by Nextcloud, so if your server is built # with the `ngx_pagespeed` module, uncomment this line to disable it. #pagespeed off; # HTTP response headers borrowed from Nextcloud `.htaccess` add_header Referrer-Policy \u0026#34;no-referrer\u0026#34; always; add_header X-Content-Type-Options \u0026#34;nosniff\u0026#34; always; add_header X-Download-Options \u0026#34;noopen\u0026#34; always; add_header X-Frame-Options \u0026#34;SAMEORIGIN\u0026#34; always; add_header X-Permitted-Cross-Domain-Policies \u0026#34;none\u0026#34; always; add_header X-Robots-Tag \u0026#34;none\u0026#34; always; add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34; always; # Remove X-Powered-By, which is an information leak fastcgi_hide_header X-Powered-By; # Path to the root of your installation root /usr/share/nginx/html/nextcloud; # Specify how to handle directories -- specifying `/index.php$request_uri` # here as the fallback means that Nginx always exhibits the desired behaviour # when a client requests a path that corresponds to a directory that exists # on the server. In particular, if that directory contains an index.php file, # that file is correctly served; if it doesn\u0026#39;t, then the request is passed to # the front-end controller. This consistent behaviour means that we don\u0026#39;t need # to specify custom rules for certain paths (e.g. images and other assets, # `/updater`, `/ocm-provider`, `/ocs-provider`), and thus # `try_files $uri $uri/ /index.php$request_uri` # always provides the desired behaviour. index index.php index.html /index.php$request_uri; # Rule borrowed from `.htaccess` to handle Microsoft DAV clients location = / { if ( $http_user_agent ~ ^DavClnt ) { return 302 /remote.php/webdav/$is_args$args; } } location = /robots.txt { allow all; log_not_found off; access_log off; } # Make a regex exception for `/.well-known` so that clients can still # access it despite the existence of the regex rule # `location ~ /(\\.|autotest|...)` which would otherwise handle requests # for `/.well-known`. location ^~ /.well-known { # The rules in this block are an adaptation of the rules # in `.htaccess` that concern `/.well-known`. location = /.well-known/carddav { return 301 $scheme://$http_host/remote.php/dav/; } location = /.well-known/caldav { return 301 $scheme://$http_host/remote.php/dav/; } location /.well-known/acme-challenge { try_files $uri $uri/ =404; } location /.well-known/pki-validation { try_files $uri $uri/ =404; } # Let Nextcloud\u0026#39;s API for `/.well-known` URIs handle all other # requests by passing them to the front-end controller. return 301 $scheme://$http_host/index.php$request_uri; } # Rules borrowed from `.htaccess` to hide certain paths from clients location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)(?:$|/) { return 404; } location ~ ^/(?:\\.|autotest|occ|issue|indie|db_|console) { return 404; } # Ensure this block, which passes PHP files to the PHP process, is above the blocks # which handle static assets (as seen below). If this block is not declared first, # then Nginx will encounter an infinite rewriting loop when it prepends `/index.php` # to the URI, resulting in a HTTP 500 error response. location ~ \\.php(?:$|/) { fastcgi_split_path_info ^(.+?\\.php)(/.*)$; set $path_info $fastcgi_path_info; try_files $fastcgi_script_name =404; include fastcgi_params; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param PATH_INFO $path_info; #fastcgi_param HTTPS on; fastcgi_param modHeadersAvailable true; # Avoid sending the security headers twice fastcgi_param front_controller_active true; # Enable pretty urls fastcgi_pass php-handler; fastcgi_intercept_errors on; fastcgi_request_buffering off; } location ~ \\.(?:css|js|svg|gif)$ { try_files $uri /index.php$request_uri; expires 6M; # Cache-Control policy borrowed from `.htaccess` access_log off; # Optional: Don\u0026#39;t log access to assets } location ~ \\.woff2?$ { try_files $uri /index.php$request_uri; expires 7d; # Cache-Control policy borrowed from `.htaccess` access_log off; # Optional: Don\u0026#39;t log access to assets } # Rule borrowed from `.htaccess` location /remote { return 301 /remote.php$request_uri; } location / { try_files $uri $uri/ /index.php$request_uri; } } } root /usr/share/nginx/html/nextcloud; 设置了网站的根目录位置；需要通过docker-compose把nextcloud中的/var/www/html映射到 root \u0026hellip; 设置的路径下。\nfastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; 用来配置fastcgi传递nginx到php-fpm的信息，/var/www/html 需要设定为nextcloud容器中网站的路径；若nginx中的网站路径使用 root \u0026hellip; 设定为与nextcloud中路径相同(/var/www/html)，则可以使用 $document_root 代替 /var/www/html。\nMariaDB 10.6兼容性问题 nextcloud25已无此问题。\nnextcloud22和mariadb10.6有兼容性问题，对docker-compose文件中mariadb的command添加\u0026ndash;innodb_read_only_compressed=OFF可暂时解决。\nhttps://github.com/nextcloud/server/issues/25436\nnextcloud 维护模式 1 2 3 cd /var/www/nextcloud sudo -u www-data php occ maintenance:mode --on sudo -u www-data php occ maintenance:mode --off ","permalink":"https://fivekernels.github.io/posts/nextcloud-with-docker/","summary":"本文介绍了在树莓派(aarch64)上使用docker的方式配置nextcloud:fpm、mariadb、nginx、redis以及onl","title":"Nextcloud With Docker"},{"content":"SysTick 介绍 Cortex-M处理器内集成了一个小型的名为SysTick的定时器，它属于NVIC的一部分；SysTick为简单的24位向下计数器，在使用操作系统时通常用作周期性中断来定期触发OS内核，用于处理任务管理和上下文切换等；当不使用操作系统时，SysTick可以当作简单定时器外设来使用（《ARM Cortex-M3与Cortex-M4权威指南（第3版）》，p215）。下图为SysTick定时器的简单框图：1 2\nSysTick定时器中存在4个寄存器，CMSIS-Core头文件中定义了一个名为SysTick的结构体，例如在STM32L4的库函数中core_cm4.h定义了如下结构体\nCubeMX 配置 点击 SYS，将 Timebase Source 选择为 SysTick（项目默认为 SysTick） 点击NVIC，配置Time base的中断优先级 在Project Manager\u0026ndash;\u0026gt;Advanced Setting中选择LL库 点击Generate Code生成代码\n代码编写与测试 在main()函数中调用的函数SystemClock_Config()中对SysTick进行初始化：\n1 2 3 4 5 6 7 8 9 ... LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1); LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1); LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1); LL_Init1msTick(80000000); LL_SetSystemCoreClock(80000000); ... 其默认提供1ms的时基：\n1 2 3 4 5 void LL_Init1msTick(uint32_t HCLKFrequency) { /* Use frequency provided in argument */ LL_InitTick(HCLKFrequency, 1000U); } 但LL库的初始化过程默认并不会开启SysTick-\u0026gt;VAL向下计数器溢出中断3（SysTick_Handler）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief This function configures the Cortex-M SysTick source of the time base. * @param HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro) * @note When a RTOS is used, it is recommended to avoid changing the SysTick * configuration by calling this function, for a delay use rather osDelay RTOS service. * @param Ticks Number of ticks * @retval None */ __STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks) { /* Configure the SysTick to have interrupt in 1ms time base */ SysTick-\u0026gt;LOAD = (uint32_t)((HCLKFrequency / Ticks) - 1UL); /* set reload register */ SysTick-\u0026gt;VAL = 0UL; /* Load the SysTick Counter Value */ SysTick-\u0026gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable the Systick Timer */ } 所以若要在中断函数SysTick_Handler()中进行程序处理，需要手动在main()函数内初始化代码后添加相关代码：4\n1 2 3 /* USER CODE BEGIN SysInit */ LL_SYSTICK_EnableIT(); /* USER CODE END SysInit */ 之后便可在计数器减至0时进入中断函数：\n微秒级精确延时 未验证，仅思路展示，需要重写考虑恢复原有延时\n1 2 3 4 5 6 7 void Delay_us(uint32_t n) //延时多少微秒，n 就输入多少 { SysTick-\u0026gt;LOAD = 72 * n; //装载计数值，因为时钟 72M，72 次在 1μs SysTick-\u0026gt;CTRL = 0x00000005; //时钟来源设为为 HCLK(72M)，打开定时器 while((SysTick-\u0026gt;CTRL \u0026amp; 0x00010000) != 0); //等待计数到 0 SysTick-\u0026gt;CTRL = 0x00000004; //关闭定时器 } 其他问题（未验证） 时钟源设置5\n生成代码中默认是以 HCLK 时钟 为 SysTick 时钟源\nReferences 《ARM Cortex-M3与Cortex-M4权威指南（第3版）》 | ISBN：9787302402923\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSTM32 的系统滴答定时器( Systick) 彻底研究解读 | cnblogs | 王健\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSTM32CubeMX 实战教程：SysTick 实验（LL 库） | CSDN | Brendon_Tan\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLL_Init1msTick disables SysTick interrupt | ST community | Bogdan Golab\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n【经验分享】填坑-关于SysTick定时器 | ST中文论坛 | STMCU小助手\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fivekernels.github.io/posts/stm32-systick-ll/","summary":"SysTick 介绍 Cortex-M处理器内集成了一个小型的名为SysTick的定时器，它属于NVIC的一部分；SysTick为简单的24位向下计数器，在","title":"STM32 SysTick LL Library"},{"content":" 基于Eclipse定制的Nios II应用程序没有集成marketplace，因此无法在线安装插件，同时手动复制离线插件到程序目录下的plugins文件夹（参考：https://blog.csdn.net/zbctop/article/details/90741420）会导致程序崩溃从而无法启动，因此将采用手动下载.epf文件的方式，使用Import-Preference实现配色的修改。\nEclipse在线主题网站：http://www.eclipsecolorthemes.org/\n修改代码字体和字号 依次点击：window\u0026ndash;\u0026gt; preference\u0026ndash;\u0026gt;General\u0026ndash;\u0026gt; Appearence\u0026ndash;\u0026gt; Colors and Fonts\u0026ndash;\u0026gt; Basic\u0026ndash;\u0026gt; Text Font,点击Edit选择喜欢的字体和大小，最后点击OK。\n常用颜色修改位置 光标处相同代码高亮 Window -\u0026gt; preferences -\u0026gt; General -\u0026gt; Editors -\u0026gt; Text Editors -\u0026gt; Annotations:\nC/C++ Occurrences 相同位置高亮颜色 C/C++ Write Occurrences 赋值语句高亮颜色 特定语法高亮 Window -\u0026gt; preferences -\u0026gt; C/C++ -\u0026gt; Editors -\u0026gt; Syntax Coloring -\u0026gt; (Elements):\nPreprocessor -\u0026gt; Directives 宏定义#include #define等 Preprocessor -\u0026gt; Headers 头文件 \u0026ldquo;main.h\u0026quot;等 Code -\u0026gt; Typedefs 通过typedef关键字定义的内容 uint等 Code -\u0026gt; Macro definitions 宏定义内容 #define后的内容 PI等 Code -\u0026gt; Macro references 宏定义的引用 代码中出现的部分PI等 修改左右侧资源管理器背景颜色 找到\u0026lt;安装目录\u0026gt;\\plugins\\org.eclipse.platform_x.x.x.vxxxxxxxx-xxxx\\css文件夹，用文本编辑器打开e4_default_win7.css（对应Theme中的Windows选项），在文件末尾添加如下内容：\n1 2 3 4 5 6 7 8 #org-eclipse-jdt-ui-PackageExplorer Tree, #org-eclipse-ui-navigator-ProjectExplorer Tree, #org-eclipse-ui-views-ContentOutline Tree, #PerspectiveSwitcher ToolBar { font-family: courier new; /* default window font */ font-size: 10px; /* default window font size*/ background-color: #FFFAE8; } 保存后重启Eclipse即可看到效果。\n此时console背景仍为默认的白色，因此可以修改在window\u0026ndash;\u0026gt; preference\u0026ndash;\u0026gt; Run/Debug\u0026ndash;\u0026gt; Console下修改Background color。\n配色方案导出 参考：CSDN[秋之菌]：eclipse配置文件导出问题\n修改Eclipse的如字体、背景、快捷键及一些template等之后，新建工作空间时eclipse仍会使用默认配置因此可以将相关配置导出后导入新的工作空间。\n使用eclipse的导出功能（不推荐，很多配置不能导出）:工作目录中右键选择Export-\u0026gt;General-\u0026gt;Preference，这样可以导出epf文件，新的工作空间中可以用Import导入该配置文件，这个方法的确可以导入绝大多数的配置，但是并不全，导入后会丢失很多配置。 方法二：将\u0026lt;workspace\u0026gt;/.metadata/.plugins/org.eclipse.core.runtime中的.settings文件夹拷贝出来，里面就是所有的配置文件，新建工作空间的时候将该.settings文件夹替换掉新工作空间中的.settings文件夹即可。（有网友是将.plugings文件夹替换，但是.plugings文件夹太大了，实际上就是替换.settings文件夹，.settings只有几百k。） 另外若需要导出界面上的工具栏对话框布局等：将该文件夹\u0026lt;workspace\u0026gt;/.metadata.plugins\\org.eclipse.e4.workbench 保存起来即可。（eclipse有不少工具，我们安排好在界面上要使用的常用工具，不希望每个工作空间都要重新将这些工具重新弄出来排版好）\n","permalink":"https://fivekernels.github.io/posts/eclipse-nios-ii-color-and-theme/","summary":"基于Eclipse定制的Nios II应用程序没有集成marketplace，因此无法在线安装插件，同时手动复制离线插件到程序目录下的plug","title":"Eclipse (Nios II) 颜色和主题自定义"},{"content":"pip换源 1 2 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/ # 清华源 pip config list # 查看当前源 使用virtualenvwrapper创建虚拟环境 参考：\nvirtualenvwrapper官方文档\nCSDN [团子大圆帅]：Python 虚拟环境管理工具介绍（virtualenv、virtualenvwrapper、pipenv）\nCSDN [zhicai_liu]：【virtualenvwrapper】重命名虚拟环境\n1 pip install virtualenvwrapper-win # 安装virtualenvwrapper，会自动安装virtualenv 安装好后默认创建的虚拟环境会位于\u0026quot;C:\\Users\u0026lt;username\u0026gt;\\envs\\\u0026ldquo;目录下;可以在环境变量-系统变量中创建WORKON_HOME，并将其值设定为需要存放的路径(如：D:\\envs)以实现修改。\n常用命令：\n1 2 3 4 5 6 7 8 9 10 11 lsvirtualenv # 查看虚拟环境 workon # 查看虚拟环境 mkvirtualenv \u0026lt;venv_name\u0026gt; # 创建名为venv_name的虚拟环境，默认python解释器继承当前环境 mkvirtualenv \u0026lt;venv_name\u0026gt; --python=\u0026lt;解释器路径\u0026gt; # 创建名为venv_name的虚拟环境，指定python解释器版本 workon \u0026lt;venv_name\u0026gt; # 激活虚拟环境 deactivate # 退出当前虚拟环境 rmvirtualenv \u0026lt;venv_name\u0026gt; # 删除虚拟环境 cdvirtualenv \u0026lt;venv_name\u0026gt; # 进入虚拟环境所在目录 cpvirtualenv \u0026lt;old_venv_name\u0026gt; \u0026lt;new_env_name\u0026gt; # 重命名虚拟环境(1/2) rmvirtualenv \u0026lt;old_venv_name\u0026gt; # 重命名虚拟环境(2/2) 使用miniconda创建虚拟环境 参考：CSDN [有马白颠]：conda、miniconda 、anaconda、 virtualenv的区别与miniconda的安装配置\nconda虚拟环境是独立于操作系统解释器环境的，即无论操作系统解释器什么版本（哪怕2.7），我也可以指定虚拟环境python版本为3.6，而venv是依赖主环境的。\n安装miniconda时，勾选“为所有用户安装”。\nconda换源 参考：\nCSDN [哈！小白要成长！]：miniconda 换源（添加镜像）\n简书 [谢小帅]：Anaconda 删除自己配置的镜像源\n1 2 3 4 5 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/ conda config --set show_channel_urls yes # 设置安装时显示源地址, 方便安装时知道包来自哪个源 查看添加结果：\n1 conda info 删除指定源：\n1 conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 换回默认源：\n1 conda config --remove-key channels 虚拟环境管理 conda create -n默认将虚拟环境创建在\u0026rdquo;$HOME/.conda/envs/env_name\u0026quot;目录下\n1 2 3 4 5 6 conda env list # 列出所有环境 conda create --name \u0026lt;env_name\u0026gt; python=3.6 # 创建虚拟环境 conda create -n \u0026lt;env_name\u0026gt; python=3.6 # 创建虚拟环境 conda activate \u0026lt;env_name\u0026gt; # 激活虚拟环境 conda deactivat # 表示退出当前环境 conda remove -n \u0026lt;env_name\u0026gt; --all # 删除虚拟环境 1 2 conda create -n \u0026lt;new_env_name\u0026gt; --clone \u0026lt;old_env_name\u0026gt; # 重命名(1/2) 复制 conda remove -n \u0026lt;old_env_name\u0026gt; --all # 重命名(2/2) 删除旧环境 此外，可以通过-p \u0026lt;path\u0026gt;或--prefix \u0026lt;path\u0026gt;的方式在指定路径下创建虚拟环境，但此时不允许使用-n \u0026lt;env_name\u0026gt;的方式指定名称：\n1 2 3 4 conda create -p \u0026lt;/path/to/environment_dir\u0026gt; python=3.6 # 在指定路径下创建虚拟环境 conda create --prefix \u0026lt;/path/to/environment_dir\u0026gt; python=3.6 # 在指定路径下创建虚拟环境 conda activate \u0026lt;/path/to/environment-dir\u0026gt; # 激活指定路径下的虚拟环境 conda remove --prefix=\u0026lt;/path/to/environment_dir\u0026gt; --all # 删除指定路径下的虚拟环境 虚拟环境草导出与导入：\n1 2 conda env export \u0026gt; environment.yaml # 生成一个包含环境名称、环境源、环境依赖包、通过pip安装的包的配置文件 conda env create -f environment.yaml # 使用配置文件创建虚拟环境 清理conda缓存：\n1 2 3 conda clean -p # 删除没有用的包 --packages conda clean -t # 删除tar打包 --tarballs conda clean --all # 删除所有的安装包及cache(索引缓存、锁定文件、未使用过的包和tar包) conda仓库简介 参考：霍小强的博客：conda、miniconda、anaconda、仓库的详解\nrepo.anaconda.com/pkgs/是 由Anaconda®公司自己构建的包的公开仓库，您仅仅具有包的使用权。此仓库仅可用于个人、教育机构学习用，如果用于商用需付费购买商业产品。\nmain channel\n大多数由 Anaconda, Inc. 使用新编译器堆栈构建的包都托管在这里。此频道作为最高优先级别频道已包含在 conda 的默认频道中。\nfree channel\n在没有新编译器堆栈的情况下构建的包。这些软件包中的大多数与 pkgs/main 中的软件包兼容。已包含在 conda 的默认频道中。\nr channel\nMicrosoft R Open conda 包和 Anaconda, Inc. 的 R conda 包。已包含在 conda 的默认频道中。\nmro channel\n这是一个空频道。此频道中的软件包已移至 pkgs/mro-archive。新的 MRO 软件包位于 pkgs/r 频道中。\npro channel\n现在已弃用——尽管仍包含在 conda 的默认频道中。最后一个软件包于 2017 年 2 月更新。包括 Anaconda, Inc. 的各个商业软件包，所有这些现在都是开源的。（MKL 优化、IOPro、加速）\narchive channel\n有时，发布到其他频道之一的软件包会出现问题，迫使 Anaconda, Inc. 将其从频道中删除。在这些情况下，程序包会存档到此频道，供任何仍然需要它的人使用。\nmro-archive channel\npkgs/mro 频道的全部内容存档，Microsoft 的 MRO 和 MRAN 的过时版本。\nmsys2 channel\n仅限 Windows。已包含在 conda 的默认频道中。Anaconda, Inc. 的 R conda 软件包以及 pkgs/main 和 pkgs/free 中的其他一些软件包是必需的。它提供了 bash shell、Autotools、修订控制系统等，用于使用 MinGW-w64 工具链构建原生 Windows 应用程序。\npenv pyenv pipenv 好像很厉害，待更新\u0026hellip;\n","permalink":"https://fivekernels.github.io/posts/python-usage/","summary":"pip换源 1 2 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/ # 清华源 pip config list # 查看当前源 使用virtualenvwrapper创建虚拟环境 参考： virtualenvwrapper","title":"Python Usage"},{"content":"清理提交历史中的敏感信息和大文件 参考：\n知乎 [彼得三三]：GitHub清除敏感信息操作\n[dotnet 职业技术学院]：清理 git 仓库太繁琐？试试 bfg！删除敏感信息删除大文件一句命令搞定（比官方文档还详细的使用说明）\n简书 [不忘初心2017]：BFG Repo-Cleaner - 从 Git 历史中真正删除文件\n使用BFG Repo-Cleaner (by rtyley)，需要java运行环境。\nBFG 默认不会 touch最新的commit，即如果你要删除的文件在最新的 commit 中，则不会删除之。为什么？因为最新的 commit 很可能是已上线在产品中的~ BFG 用的是仓库镜像 git clone \u0026ndash;mirror。 如果要删除的文件在受保护的commit中，BFG 不会删，不建议删。至于commit什么情况下会受保护，我还不太清楚。 首先将待清理的仓库克隆到本地，记得clone后备份一份xxx.git到其他位置，以免操作失误。\n1 git clone --mirror git://example.com/xxx.git 将下载的bfg.jar与xxx.git放到同一个同目录。\n清理敏感信息 准备一个文本文件passwords.txt，名称任意，里面包含要要替换的文本：\n1 2 3 4 5 PASSWORD1 # Replace literal string \u0026#39;PASSWORD1\u0026#39; with \u0026#39;***REMOVED***\u0026#39; (default) PASSWORD2==\u0026gt;examplePass # replace with \u0026#39;examplePass\u0026#39; instead PASSWORD3==\u0026gt; # replace with the empty string regex:password=\\w+==\u0026gt;password= # Replace, using a regex regex:\\r(\\n)==\u0026gt;$1 # Replace Windows newlines with Unix newlines 执行敏感信息替换：\n1 java -jar bfg.jar --replace-text passwords.txt xxx.git 回收已经没有引用的旧提交，这可以减小本地仓库的大小：\n1 git reflog expire --expire=now --all \u0026amp;\u0026amp; git gc --prune=now --aggressive 推回远端仓库：\n1 git push 更新本地代码推荐删除原有工程，重新clone仓库后配置工程，注意原有工程下.gitignore的重要文件（敏感信息等）。\n清理大文件 1 2 3 4 java -jar bfg.jar --strip-blobs-bigger-than 500M xxx.git # 将仓库历史中大于 500M 的文件都删除掉 java -jar bfg.jar --delete-files walterlv.snk xxx.git # 删除特定文件 walterlv.snk java -jar bfg.jar --delete-files {walterlv,lindexi}.snk xxx.git # 删除 walterlv.snk 或 lindexi.snk 文件 java -jar bfg.jar --delete-folders walterlv xxx.git # 删除名字为 walterlv 的文件夹 回收已经没有引用的旧提交，这可以减小本地仓库的大小：\n1 git reflog expire --expire=now --all \u0026amp;\u0026amp; git gc --prune=now --aggressive 推回远端仓库：\n1 git push 更新本地代码推荐删除原有工程，重新clone仓库后配置工程，注意原有工程下.gitignore的重要文件（敏感信息等）。\n子模块submodule的使用 参考：\nCSDN [guotianqing]：git中submodule子模块的添加、使用和删除\n简书 [thinker_g]：[Git] 如何优雅的删除子模块(submodule)或修改Submodule URL\n添加 1 2 git submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; git commit # 提交？ 其中，url为子模块的路径，path为该子模块存储的目录路径。\n修改模块url 修改\u0026rsquo;.gitmodules\u0026rsquo;文件中对应模块的”url“属性; 使用git submodule sync命令，将新的URL更新到文件.git/config； git commit -am \u0026ldquo;Update submodule url.\u0026rdquo; # 提交变更 删除 1 2 3 4 5 6 7 git submodule deinit \u0026lt;MOD_NAME\u0026gt; # 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空 git rm --cached \u0026lt;MOD_NAME\u0026gt; # 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存） # rm -rf \u0026lt;子模块目录\u0026gt; # 删除子模块目录及源码 # vi .gitmodules # 删除项目目录下.gitmodules文件中子模块相关条目 vi .git/config # 删除配置项中子模块相关条目 # rm .git/module/* # 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 git commit -am \u0026#34;Remove a submodule.\u0026#34; ","permalink":"https://fivekernels.github.io/posts/git-usage/","summary":"清理提交历史中的敏感信息和大文件 参考： 知乎 [彼得三三]：GitHub清除敏感信息操作 [dotnet 职业技术学院]：清理 git 仓库太繁琐？试试 bfg！删除敏感","title":"Git Usage"},{"content":"基于 AutoApi v6.4\nfork from https://github.com/Innersider/cactial-AutoAPI.git\n基本知识 v6.4 action 添加结束workflow? https://github.com/canmeng99/AutoApi\n1 2 3 4 5 6 7 8 9 build: ...... steps: ...... - name: Delete workflow runs uses: GitRML/delete-workflow-runs@main with: retain_days: 1 keep_minimum_runs: 1 添加 workflow 保持action活跃 action keep workflow alive https://github.com/ccknbc-actions/E5-Developer\n","permalink":"https://fivekernels.github.io/posts/microsoft365-e5-renew-with-github-actions/","summary":"基于 AutoApi v6.4 fork from https://github.com/Innersider/cactial-AutoAPI.git 基本知识 v6.4 action 添加结束workflow? https://github.com/canmeng99/AutoApi 1 2 3 4 5 6 7 8 9 build: ...... steps: ...... - name: Delete workflow runs uses: GitRML/delete-workflow-runs@main with: retain_days: 1 keep_minimum_runs: 1 添加 workflow 保持action活跃 action keep workflow alive https://github.com/ccknbc-actions/E5-Developer","title":"Microsoft365 E5 续订——Github Actions"},{"content":" 开启 Fiddler 抓包时，python 中的 requests.get()、requests.post() 数据包无法捕获，且在请求 https 时会产生 ssl.SSLError: [SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1091) 错误。因此对于其请求应当做一定的修改。\n该方法对 requests 的版本有要求，certifi 目前使用最新版（2021.10.8）没有问题。\n1 2 pip install requests==2.19.1 pip install certifi==2018.8.13 Fiddler 证书导出 打开 Fiddler，依次选择 Tools-Options\u0026hellip;-HTTPS，点击右侧 Actions 中的 Open Windows Certificate Manager。\n展开个人-证书，在右侧找到证书“DO_NOT_TRUST_FiddlerRoot”，右键-所有任务-导出。不导出私钥、选择编码方式为 Base64 X.509，得到 .cer 格式的文件。\nrequests 参数设置 将得到的 .cer 文件后缀改为 .crt，放到项目文件夹下，在 requests 请求前添加如下配置并添加请求参数即可。\n1 2 3 proxies = {\u0026#39;http\u0026#39;:\u0026#39;http://127.0.0.1:8888\u0026#39;,\u0026#39;https\u0026#39;:\u0026#39;https://127.0.0.1:8888\u0026#39;} certFile = \u0026#39;.\\fiddlerCert.crt\u0026#39;) r = requests.get(\u0026#34;https://exampleurl.example.com\u0026#34;, proxies=proxies, verify=certFile) 此后即可用 Fiddler 对 requests 请求于响应进行抓包。\n","permalink":"https://fivekernels.github.io/posts/python-requests-with-fiddler/","summary":"开启 Fiddler 抓包时，python 中的 requests.get()、requests.post() 数据包无法捕获，且在请求 https 时会产生 ssl.SSLError: [SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1091) 错","title":"使用 Fiddler 对 Python requests 请求进行抓包"},{"content":"Nginx 变量 赋值 变量名以 $ 开头：$hello 变量仅有一种类型：字符串 每行语句以分号结尾 使用 set 指令对变量赋值： 1 set $hello \u0026#34;hello\u0026#34;; 取值 使用变量时将变量写在双引号内，将会自动将其替换为实际内容 写在单引号内的变量不会被替换 1 print \u0026#34;this is $hello world.\u0026#34;; 变量后紧跟构成变量名的字符（字母、数字、下划线等），使用大括号消除歧义 1 print \u0026#34;this is ${hello}world.\u0026#34;; 详细信息：\nhttps://blog.csdn.net/u014296316/article/details/80973530\nhttp://blog.sina.com.cn/s/blog_6d579ff40100wi7p.html\n拼接 1 set $allUrl \u0026#34;${host}${request_uri}\u0026#34;; 内置变量 url 相关 $http_host $server_name $request_uri $uri\u0026lt;\u0026gt; $arg_\u0026lt;PARAMETER\u0026gt;: 客户端GET请求中 \u0026lt;PARAMETER\u0026gt;字段的值 客户端证书 参考：CSDN涂宗勋：nginx获取ca证书信息并传递到java后端使用\nnginx内部解析证书后，会把相关信息放到内置的变量中\n$ssl_client_cert：证书内容 $ssl_client_serial：证书序列号 $ssl_client_s_dn：证书subject 若要将客户端信息传递到后端，可以在 Nginx 配置文件中的 location 内加入 header 配置：\n1 2 3 4 5 6 location / { ...... proxy_set_header X-SSL-Client-Cert $ssl_client_cert; proxy_set_header X-SSL-serial $ssl_client_serial; proxy_set_header cert-subject $ssl_client_s_dn; } 其中，X-SSL-Client-Cert、X-SSL-serial、cert-subject为自定义变量名，供后端代码（java等）获取header值使用。\n1 2 3 4 5 6 public class CaController { @GetMapping(\u0026#34;/test\u0026#34;) public String caTest(@RequestHeader(\u0026#34;X-SSL-serial\u0026#34;) String serial, @RequestHeader(\u0026#34;X-SSL-Client-Cert\u0026#34;) String cert, @RequestHeader(\u0026#34;cert-subject\u0026#34;) String subject) { return serial + \u0026#34; \\r\u0026#34; + cert + \u0026#34; \\r\u0026#34; + subject; } } 表达式 正则表达式 regex 字符 描述 ^ 匹配输入字符串的起始位置 $ 匹配输入字符串的结束位置 \\d 匹配数字 \\ 将后面接着的字符标记为一个特殊字符或一个原义字符或一个向后引用。如\u0026quot;\\n\u0026quot;匹配一个换行符，而\u0026quot;\\$\u0026ldquo;则匹配\u0026rdquo;$\u0026quot; [c] 匹配单个字符c [a-z] 匹配 a-z 任意一个小写字母 . 匹配除换行符\u0026quot;\\n\u0026quot;之外的任何单个字符；若要匹配包括\u0026quot;\\n\u0026quot;在内的任意字符，使用如\u0026quot;[.\\n]\u0026ldquo;等模式。 {n} 重复n次 {n,} 重复n次或更多次 ? 匹配前面的字符0次或1次。如\u0026quot;do(es)?\u0026ldquo;能匹配\u0026quot;do\u0026quot;或者\u0026quot;does\u0026rdquo;，\u0026rdquo;?\u0026ldquo;等价于\u0026rdquo;{0,1}\u0026quot; * 匹配前面的字符0次或多次。如\u0026quot;ol*\u0026ldquo;能匹配\u0026quot;o\u0026quot;及\u0026quot;ol\u0026rdquo;、\u0026ldquo;oll\u0026rdquo; + 匹配前面的字符1次或多次。如\u0026quot;ol+\u0026ldquo;能匹配\u0026quot;ol\u0026quot;及\u0026quot;oll\u0026rdquo;、\u0026ldquo;oll\u0026rdquo;，但不能匹配\u0026quot;o\u0026quot; (pattern) 匹配括号内pattern并可以在后面获取对应的匹配，常用$0...$9属性获取小括号中的匹配内容，要匹配圆括号字符需要Content 比较 数值比较:\n比较两个变量/变量与字符串是否相等\n符号 说明 = 相等 != 不相等 正则比较:\n变量与正则表达式的模式是否匹配\n符号 说明 ~ 匹配，区分大小写 ~* 匹配，不区分大小写 !~ 不匹配，区分大小写 !~* 不匹配，不区分大小写 Nginx 在匹配正则时会生成对应表达式中括号被匹配字符的变量，从左至右依次为：$1|$2|$3……可供后续程序中使用匹配内容。例如字符串\u0026quot;ID=user1_acdefg9876543GHI\u0026quot;，使用正则表达式\u0026quot;(ID=([-_a-zA-Z0-9]+))\u0026ldquo;进行匹配，所生成的变量：\n1 2 $1 = ID=user1_acdefg9876543GHI; $2 = user1_acdefg9876543GHI; rewrite 将URL重定向。基本过程：（参考：博客园Dy1an：【04】Nginx：rewrite / if / return / set 和变量）\n用户请求到达某个server，如果满足server内rewrite的正则匹配，那么rewrite将会对用户请求URI重写。 重写完成后直接在该server内部去匹配location。 当匹配到location后，如果location内部又有rewrite，那执行rewrite；之后再次在这个server内部去匹配location，直到请求返回。 这个过程不是无限的，nginx对于这样的跳转就支持10次，如果过多甚至死循环，则会报500错误。 基本语法：\n1 rewrite regex replacement [flag]; Examples Example 1 在正则比较中使用变量（参考：腾讯云社区问答：如何在nginx“if”正则表达式中使用变量？）\n以下语句似乎不起作用\n1 2 3 4 set $chk == \u0026#34;need\u0026#34;; set $me \u0026#34;kevin\u0026#34;; if ($uri ~ \u0026#34;by-{$me}\u0026#34;) { set $chk \u0026#34;\u0026#34;; } if ($chk == \u0026#34;need\u0026#34;) { ... } Solution [待验证]\n1 2 3 4 5 set $chk == \u0026#34;need\u0026#34;; set $me \u0026#34;kevin\u0026#34;; if ($uri ~ /by-([^-]+)/) { set $by $1; } if ($by = $me) {set $chk \u0026#34;\u0026#34;;} if ($chk == \u0026#34;need\u0026#34;) { ... } Example 2 去掉指定的url参数（去掉url中的start=\u0026hellip;，保留其他参数）：（参考segmentfault sPeng）\nSolution1 [待验证]\n1 2 3 4 5 6 7 8 9 10 location ~* filename(\\d+)\\.html$ { root /var/www/html; index index.html; if ($query_string ~ ^(.*)\u0026amp;start=(\\d+)\u0026amp;(.*)) { set $a $1; set $b $2; set $c $3; rewrite ^ /filename1?${a}\u0026amp;${c}? break; } } Solution2 [待验证]\n1 rewrite ^(.*?)start=\\d+\\\u0026amp;?(.*)$ $1$2 last; ","permalink":"https://fivekernels.github.io/posts/nginx-variable-and-expression-configuration/","summary":"Nginx 变量 赋值 变量名以 $ 开头：$hello 变量仅有一种类型：字符串 每行语句以分号结尾 使用 set 指令对变量赋值： 1 set $hello \u0026#34;hello\u0026#34;; 取值 使用变量时将变量写在双引号","title":"Nginx 语法 变量和表达式"},{"content":"Hugo 主题配置——Papermod 官方链接：\ngithub: https://github.com/adityatelange/hugo-PaperMod github wiki:https://github.com/adityatelange/hugo-PaperMod/wiki demo code: https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/ demo: https://adityatelange.github.io/hugo-PaperMod// Papermod 主题默认使用 .yaml 格式作为配置文件，因此新建网站时可以使用 -f 设置 yml 格式：\n1 hugo new site \u0026lt;name of site\u0026gt; -f yml 将主题添加到网站文件夹中：\n1 2 git submodule add git@github.com:adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 导航菜单与页面配置 \u0026hellip;待更新\u0026hellip;\n首页样式配置 \u0026hellip;待更新\u0026hellip;\n文章顶端信息 参考：Sulv\u0026rsquo;s Blog：Hugo博客修改post_meta头部信息\n添加文章修改日期 将theme目录下的文件：layouts/partials/post_meta.html，复制到layouts对应目录下，并添加以下内容：\n1 2 3 4 \u0026lt;!-- 更新时间 --\u0026gt; {{- if (.Param \u0026#34;ShowLastMod\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;Updated:\u0026amp;nbsp;%s\u0026#34; (.Lastmod.Format (.Site.Params.dateFormat | default \u0026#34;January 2, 2006\u0026#34;)))) }} {{- end }} 在Hugo的配置文件config.yml中的params下添加以下内容：\n1 2 3 params: ... ShowLastMod: true # 显示文章更新时间 配合post_meta.html 文章开头添加相应字段即可：\n1 lastmod: 2022-03-18T13:59:59+08:00 此外，可以在archetypes/default.md中添加lastmod字段，之后创建文章时会自动生成该部分内容。\n1 lastmod: {{ .Date }} 其他样式也可以酌情进行修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 {{- $scratch := newScratch }} \u0026lt;!-- 创建时间 --\u0026gt; {{- if not .Date.IsZero -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;创建:\u0026amp;nbsp;\u0026lt;span title=\u0026#39;%s\u0026#39;\u0026gt;%s\u0026lt;/span\u0026gt;\u0026#34; (.Date) (.Date.Format (default \u0026#34;January 2, 2006\u0026#34; .Site.Params.DateFormat)))) }} {{- end }} \u0026lt;!-- 更新时间 --\u0026gt; {{- if (.Param \u0026#34;ShowLastMod\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;更新:\u0026amp;nbsp;%s\u0026#34; (.Lastmod.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;)))) }} {{- end }} \u0026lt;!-- 统计字数 --\u0026gt; {{- if (.Param \u0026#34;ShowWordCounts\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;字数:\u0026amp;nbsp;%d字\u0026#34; .WordCount))) }} {{- end }} \u0026lt;!-- 大概需要花费的阅读时间 --\u0026gt; {{- if (.Param \u0026#34;ShowReadingTime\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;时长: %d分钟\u0026#34; .ReadingTime))) }} {{- end }} \u0026lt;!-- 作者 --\u0026gt; {{- with (partial \u0026#34;author.html\u0026#34; .) }} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice .) }} {{- end }} \u0026lt;!-- 分隔方式 --\u0026gt; {{- with ($scratch.Get \u0026#34;meta\u0026#34;) }} {{- delimit . \u0026#34;\u0026amp;nbsp;|\u0026amp;nbsp;\u0026#34; -}} {{- end -}} 作者的中文显示要找到layouts/partials/author.html，在如下位置加入中文\n1 作者:\u0026amp;nbsp;{{- $author := (.Params.author | default .Site.Params.author) }} 文章基础配置 \u0026hellip;待更新\u0026hellip;\n文章目录 TOC 侧边放置 参考：\nToc on the side | Github Pull Requests | nielsbrakel\nSulv\u0026rsquo;s Blog: Hugo博客目录放在侧边 | PaperMod主题\ntoc代码 在Hugo根目录下的layouts文件夹下新建partials文件夹，并建立文件toc_side.html（\u0026lt;siteroot\u0026gt;/layouts/partials/toc_side.html），layouts文件夹中的内容优先级高于theme中主题的layouts文件夹。输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 {{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 调用代码 找到主题目录下的layouts/_default/single.html文件，将其复制到根目录下的layouts/_default/single.html中，找到其调用代码\n1 2 3 {{- if (.Param \u0026#34;ShowToc\u0026#34;) }} {{- partial \u0026#34;toc.html\u0026#34; . }} {{- end }} 修改为\n1 2 3 4 {{- if (.Param \u0026#34;ShowToc\u0026#34;) }} \u0026lt;!-- {{- partial \u0026#34;toc.html\u0026#34; . }} --\u0026gt; {{- partial \u0026#34;toc_side.html\u0026#34; . }} {{- end }} 修改css 在Hugo根目录新建assets文件夹，此时该目录比theme主题目录中的assets文件夹具有更高的优先级。在根目录下的assets中创建css/extended/blank.css，加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 :root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { /* list-style: none; */ /* 不显示目录前的小圆圈 */ font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 重新生成站点即可预览效果。\n代码样式设置 Hugo 默认支持 Chroma，但可选的高亮主题不多，点击查看主题列表。\n在配置文件中禁用 highlight.js，然后使用自带的高亮主题；如果不设置 disableHLJS: true，highlight.js 会覆盖 Chroma 主题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 params: assets: disableHLJS: true # ... markup: highlight: codeFences: true guessSyntax: true lineNos: true anchorLineNos: false # 行号锚点（特别丑！） # lineNumbersInTable: true noClasses: false tabWidth: 4 style: dracula 但是如果对于代码块中启用了高亮某些行时，行号大于10的时候将会显示不正常，此时只能配置 noClasses: false 并手动使用hugo生成css文件：\n1 hugo gen chromastyles --style dracula \u0026gt; assets/css/extended/dracula.css 代码块中的背景色默认是不随亮暗主题改变的，可以在 assets/css/extended/blank.css 中添加以下内容调整不同的背景色：\n1 2 3 4 5 6 :root { --hljs-bg: #282C34; } .dark { --hljs-bg: #1c1c1c; } Reference https://github.com/adityatelange/hugo-PaperMod/issues/923\nhttps://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma\nhttps://dvel.me/posts/hugo-papermod-config/#%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE\n","permalink":"https://fivekernels.github.io/posts/hugo-configuration-theme-papermod/","summary":"Hugo 主题配置——Papermod 官方链接： github: https://github.com/adityatelange/hugo-PaperMod github wiki:https://github.com/adityatelange/hugo-PaperMod/wiki demo code: https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/ demo: https://adityatelange.github.io/hugo-PaperMod// Papermod 主题默认使用 .yaml 格式作为配置文件，因此新建网站时可以使用 -f 设置 yml 格式： 1 hugo new site \u0026lt;name of","title":"Hugo 主题配置——Papermod"},{"content":"站点配置 从Hugo主题网站上找一个喜欢的主题，使用git同步到本地代码仓库的themes文件夹。下面挑了两个比较喜欢的：\n1 2 git submodule add git@github.com:dillonzq/LoveIt.git themes/LoveIt git submodule add git@github.com:google/docsy.git themes/docsy 将主题信息写入hugo配置文件config.toml，在config.toml添加一行：\n1 theme = \u0026#34;LoveIt\u0026#34; 同时可以配置一下其他信息，某些主题会有特定的规范。以LoveIt主题为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 baseURL = \u0026#34;http://example.org/\u0026#34; defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 默认语言 [en, zh-cn, fr, ...] languageCode = \u0026#34;zh-CN\u0026#34; # 网站语言, 仅在这里 CN 大写 hasCJKLanguage = true # 是否包括中日韩文字 title = \u0026#34;我的全新 Hugo 网站\u0026#34; # 网站标题 # 更改使用 Hugo 构建网站时使用的默认主题 theme = \u0026#34;LoveIt\u0026#34; [params] # LoveIt 主题版本 version = \u0026#34;0.2.X\u0026#34; [menu] [[menu.main]] identifier = \u0026#34;posts\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;文章\u0026#34; url = \u0026#34;/posts/\u0026#34; # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;分类\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 待补充\u0026hellip;\n","permalink":"https://fivekernels.github.io/posts/hugo-configuration-theme-loveit/","summary":"站点配置 从Hugo主题网站上找一个喜欢的主题，使用git同步到本地代码仓库的themes文件夹。下面挑了两个比较喜欢的： 1 2 git submodule add git@github.com:dillonzq/LoveIt.git themes/LoveIt git submodule add","title":"Hugo 主题配置——loveit"},{"content":"Hugo 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .(hugo-root) |-- archetypes/ (内容模板文件) |-- assets/ (not created by default) | |-- css/ (adding custom css to replace css in themes) | | |-- *.* | | `-- *.* | `-- ***/ |-- content/ (存放文章内容，通过\u0026#34;hugo new\u0026#34;创建的文件以此为根目录) | `-- posts/ | `-- *.md |-- data/ (存储网站用到一些配置、数据文件。文件类型可以是yaml|toml|json等格式，生成网站时使用) |-- docs/ (github pages可以选用docs作为网站根目录，添加publishdir: \u0026#39;docs\u0026#39;将网站生成在该目录下) |-- layouts/ (渲染文章内容的模板文件，相较于themes/\u0026lt;theme-name\u0026gt;/layouts目录下的同名文件具有更高优先级) |-- resources/ |-- static/ (存储图片、css、js等静态资源文件；md中引用图片的根目录位于此文件夹下) |-- themes/ (存储不同主题，可以方便的切换网站的风格样式) `-- config.yml (或config.toml，config.json，网站默认配置文件) tree \u0026ndash;dirsfirst \u0026ndash;charset=ascii /path/to/directory将生成一个很好的ASCII树，可以将其整合到文档中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 (example fire tree) | |-- de-DE | | |-- art.mshc | | |-- artnoloc.mshc | | |-- clientserver.mshc | | |-- noarm.mshc | | |-- resources.mshc | | `-- windowsclient.mshc | `-- en-US | |-- art.mshc | |-- artnoloc.mshc | |-- clientserver.mshc | |-- noarm.mshc | |-- resources.mshc | `-- windowsclient.mshc `-- IndexStore |-- de-DE | |-- art.mshi | |-- artnoloc.mshi | |-- clientserver.mshi | |-- noarm.mshi | |-- resources.mshi | `-- windowsclient.mshi `-- en-US |-- art.mshi |-- artnoloc.mshi |-- clientserver.mshi |-- noarm.mshi |-- resources.mshi `-- windowsclient.mshi 配置文件分离设计 \u0026hellip;待更新\u0026hellip;\n静态资源（图片等）存放方式 参考：\nHugo官方文档-Oorganization\nHugo官方文档-Page Bundles\n选择合适的内容组织方式：（参考：Hugo: Leaf and Branch Bundles）\n\u0026hellip;待更新\u0026hellip;\n配置生成leaf bundles类型文章的模板 参考：\nHugo官方文档-Archetypes\nstackoverflow：adding a page bundle with hugo new\n在archetypes文件夹内创建如下文件结构：\n1 2 3 4 5 .(archetypes) |-- post-bundle/ \u0026lt;-- (create) | |-- images/ \u0026lt;-- (an empty dir will be generated) | `-- index.md \u0026lt;-- (write archetype in, similar as default.md) `-- default.md 其中，post-bundle文件夹下的内容将作为模板在创建文章时自动生成；在index.md文件中写入以下内容：\n1 2 3 4 5 6 7 8 9 10 --- title: {{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }} date: {{ .Date }} lastmod: {{ .Date }} tags: - default categories: - default draft: true --- 执行以下命令，将会在posts文件夹下生成名为\u0026quot;post(dir)name\u0026quot;的文件夹，并在其中自动创建index.md和images空文件夹（与archetypes文件夹下的post-bundle具有相同结构）。\n1 hugo new --kind post-bundle posts/\u0026lt;post(dir)name\u0026gt; ","permalink":"https://fivekernels.github.io/posts/hugo-content-management/","summary":"Hugo 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .(hugo-root) |-- archetypes/ (内容模板文件) |-- assets/ (not created by default) | |-- css/ (adding custom css to replace css in themes) | | |-- *.* | | `-- *.* | `-- ***/ |-- content/ (存放文章内容","title":"Hugo 文件管理"},{"content":"GitHub Pages GitHub Pages 本质上是一个静态网站托管系统，比较常用的是个人站点，也就是创建名为\u0026quot;\u0026lt;username\u0026gt;.github.io\u0026quot;的仓库作为一个静态网页入口。它有3种存在方式：\n识别 main branch 根目录下的：README.md 或 index.html 识别 main branch /docs 目录下的：README.md 或 index.html 识别 gh-pages branch 根目录下的：README.md 或 index.html 因此我们可以在GitHub上创建一个名为\u0026lt;username\u0026gt;.github.io的public仓库，如果想方便的查看效果，可以勾选生成默认的readme.md，之后访问\u0026lt;username\u0026gt;.github.io即可看到效果。如果希望自定义网页内容，则可以不勾选生成readme.md，而将其克隆到本地：\n1 2 3 git clone git@github.com:\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git cd \u0026lt;username\u0026gt;.github.io echo \u0026#34;Hello World\u0026#34; \u0026gt; index.html 之后推到GitHub，访问\u0026lt;username\u0026gt;.github.io即可看到效果。\n1 2 3 git add --all git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main 参考：GitHub官方教程\nHugo 官网连接： Hugo_Quick-Start\n下载 Hugo Github https://github.com/gohugoio/hugo/releases\nWindows中无需安装，解压到喜欢的位置后将hugo.exe所在路径添加到环境变量中（可选）即可。 在git bash中敲入一下命令确认可以执行；不建议使用Powershell，因为后续使用echo等命令时会造成乱码。\n1 hugo version 创建 Hugo 站点 1 hugo new site quickstart 找到一个你喜欢在本地存放代码的文件夹，执行这段代码，然后存放代码仓库的文件夹“quickstart”将会被创建，内部已经生成了Hugo所必须的一些代码。此时可以切换到代码仓库：\n1 cd quickstart 之后可以使用git初始化代码仓库：\n1 git init 站点配置 打开站点目录下的 config.toml (或 config.yml)，添加或修改如下配置信息：\n1 2 3 4 5 6 7 8 languageCode: zh-CN # CN大写? publishdir: \u0026#39;docs\u0026#39; # 发布文件夹，配合 github pages 将网页文件生成到docs文件夹中 defaultContentLanguage: \u0026#34;zh-cn\u0026#34; # 默认语言[en, zh-cn, fr, ...] 影响生成html的lang hasCJKLanguage: true # 包含中日韩文等，使字数统计准确 isCJKLanguage: true theme: \u0026#34;PaperMod\u0026#34; # 选择的主题的文件夹名 代码行号 上述配置并不能将网页内代码行号显示出来，因此在[markup.highlight]下添加配置（具体参见官方文档）：\n1 linenos = true 其他未测试配置（来自https://huangzhongde.cn/post/2020-02-22-hugo-code-linenumber/）\n1 2 3 4 5 6 7 8 9 10 11 12 pygmentsUseClasses = true [markup] [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \u0026#34;\u0026#34; lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true style = \u0026#34;github\u0026#34; tabWidth = 4 防复制行号（未测试、可能使用的主题不需要配置）\n1 2 3 4 5 6 7 8 9 .highlight .ln { width: 20px; display: block; float: left; text-align: right; user-select: none; /* 复制是不能被选中，其他的是格式上的调整 */ padding-right: 8px; color: #ccc; } 其他配置详见 Hugo 主题配置文章\n创建文章 1 2 hugo new \u0026lt;content内文件夹路径\u0026gt;/\u0026lt;文章文件名.md\u0026gt; hugo new posts/my-first-post.md 以上命令在代码仓库中content\\posts文件夹中创建文章草稿\u0026quot;my-first-post.md\u0026quot;。\n打开\u0026quot;my-first-post.md\u0026quot;，文件开头\u0026quot;\u0026mdash;\u0026ldquo;之间已经存在预先生成的信息：\n1 2 3 4 5 --- title: \u0026#34;my-first-post\u0026#34; date: 2021-10-21T20:09:21+08:00 draft: true --- draft默认为true，此时不会被生成到网页中；编辑完成内容后将其修改为false以参与网页构建，或使用-D参数使草稿临时参与构建。\n构建网页 在本地生成，-D表示构建草稿。使用浏览器访问http://localhost:1313进行预览。\n1 hugo server -D 正式构建网页，默认构建在/public目录中。输入hugo的生成方式只会往public文件夹里添加内容，但是不会删除外部已经不存在而public里面还存在的文件。所以我一般用hugo -F \u0026ndash;cleanDestinationDir命令，表示每次生成的public都是全新的，会覆盖原来的。\n1 2 3 hugo hugo -D hugo -F --cleanDestinationDir -D 将 Hugo 与 GitHub 建立连接 Github Pages中静态文件的存放位置有以下三种：（仓库中settings）\nmain 分支 main 分支下docs目录 gh-pages 分支(前提是这个分支存在) 为实现hugo静态页面的发布，可以在config.toml中添加以下配置：\n1 publishdir = \u0026#39;docs\u0026#39; 此后运行hugo命令将会使生成的网页文件保存在/docs目录下。将整个代码仓库推送到GitHub的main分支上，并在settings中设置站点source为main /docs。访问https://\u0026lt;username\u0026gt;.github.io即可看到成果。\n使用main分支的docs文件夹的好处是推一次代码就可以将源文档和构建的页面一起发布到GitHub中；如果希望对源文档和构建页面分别进行版本管理，则可以单独新建分支gh-pages（未测试）：参考https://zhuanlan.zhihu.com/p/37752930\n无需修改hugo的publishdir，直接将/public子目录添加到.gitignore文件中，使main分支忽略其更新；之后新建分支gh-pages。\n1 2 3 4 5 6 7 8 # 忽略public子目录 echo \u0026#34;public\u0026#34; \u0026gt;\u0026gt; .gitignore # 初始化gh-pages branch git checkout --orphan gh-pages git reset --hard git commit --allow-empty -m \u0026#34;Initializing gh-pages branch\u0026#34; git push origin gh-pages git checkout master 为了提高每次发布的效率，可以将下述命令存在脚本中，每次只需要运行该脚本即可将gh-pages branch中的文章发布到Github的repo中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/sh if [[ $(git status -s) ]] then echo \u0026#34;The working directory is dirty. Please commit any pending changes.\u0026#34; exit 1; fi echo \u0026#34;Deleting old publication\u0026#34; rm -rf public mkdir public rm -rf .git/worktrees/public/ echo \u0026#34;Checking out gh-pages branch into public\u0026#34; git worktree add -B gh-pages public origin/gh-pages echo \u0026#34;Removing existing files\u0026#34; rm -rf public/* echo \u0026#34;Generating site\u0026#34; hugo echo \u0026#34;Updating gh-pages branch\u0026#34; cd public \u0026amp;\u0026amp; git add --all \u0026amp;\u0026amp; git commit -m \u0026#34;Publishing to gh-pages (publish.sh)\u0026#34; echo \u0026#34;Push to origin\u0026#34; git push origin gh-pages 最后将main分支中的源文档和gh-pages分支h中的网页文档分别push到Github仓库中，进入settings将source选定gh-pages即可。\n部署到 Github Pages 后无法正常显示样式 有些时候，hugo在本地预览没有问题，但当部署到github pages后样式无法正常显示，出现SRI（完整性检查）的问题，浏览器console报错：Failed to find a valid digest in the \u0026lsquo;integrity\u0026rsquo; attribute for resource\u0026hellip;The resource has been blocked。这是由于在Windows下拉取的仓库默认会被git转换成CRLF换行符，而推到github上时代码被转换成了LF；这就导致了hugo生成代码时计算的校验和和推送后的代码校验和不一致，因此浏览器无法加载。可以选择下列的几种方式解决：\n禁止Windows下的git在拉取代码时的自动转换行为： 1 git config --global core.autocrlf input # 提交时转换为LF，拉取时不转换 通过使用.gitattributes文件对换行符进行说明，让git对于css文件强制以crlf签出： 1 *.css text eol=crlf 在hugo中关闭SRI： 1 2 3 params: assets: disableFingerprinting: true （不推荐）禁用签名；将 themes\\PaperMod\\layouts\\partials\\ 下的 head.html 中的 integrity=\u0026rdquo;{{ $stylesheet.Data.Integrity }}\u0026quot; 改为 integrity=\u0026quot;\u0026quot;，并重新生成。 Reference:\nhttps://github.com/lxndrblz/anatole/issues/114#issuecomment-1079609969\nhttps://github.com/adityatelange/hugo-PaperMod/issues/89\nhttps://smc.im/post/resolve-integrity-error-in-hugo/\n","permalink":"https://fivekernels.github.io/posts/deploy-githubpages-by-hugo/","summary":"GitHub Pages GitHub Pages 本质上是一个静态网站托管系统，比较常用的是个人站点，也就是创建名为\u0026quot;\u0026lt;username\u0026gt;.github.io\u0026","title":"使用 Hugo 搭建 GitHub Pages"},{"content":"h2 标题 h3 标题 纯文本\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\nlihe! ihe! he! e! ! 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello world\u0026#34;); return 0; } ","permalink":"https://fivekernels.github.io/posts/my-first-post/","summary":"h2 标题 h3 标题 纯文本\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;. lihe! ihe! he! e! ! 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello world\u0026#34;); return 0; }","title":"My First Post"}]